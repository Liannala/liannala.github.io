<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap源码解析</title>
    <url>/2022/02/01/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、JDK1-8"><a href="#一、JDK1-8" class="headerlink" title="一、JDK1.8"></a>一、JDK1.8</h1><h2 id="1、总的介绍"><a href="#1、总的介绍" class="headerlink" title="1、总的介绍"></a>1、总的介绍</h2><p>官方注释摘录如下：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span></span><br><span class="line"><span class="comment"> * implementation provides all of the optional map operations, and permits</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</span></span><br><span class="line"><span class="comment"> * unsynchronized and permits nulls.)  This class makes no guarantees as to</span></span><br><span class="line"><span class="comment"> * the order of the map; in particular, it does not guarantee that the order</span></span><br><span class="line"><span class="comment"> * will remain constant over time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation provides constant-time performance for the basic</span></span><br><span class="line"><span class="comment"> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span></span><br><span class="line"><span class="comment"> * disperses the elements properly among the buckets.  Iteration over</span></span><br><span class="line"><span class="comment"> * collection views requires time proportional to the &quot;capacity&quot; of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</span></span><br><span class="line"><span class="comment"> * of key-value mappings).  Thus, it&#x27;s very important not to set the initial</span></span><br><span class="line"><span class="comment"> * capacity too high (or the load factor too low) if iteration performance is</span></span><br><span class="line"><span class="comment"> * important.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its</span></span><br><span class="line"><span class="comment"> * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial</span></span><br><span class="line"><span class="comment"> * capacity is simply the capacity at the time the hash table is created.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to</span></span><br><span class="line"><span class="comment"> * get before its capacity is automatically increased.  When the number of</span></span><br><span class="line"><span class="comment"> * entries in the hash table exceeds the product of the load factor and the</span></span><br><span class="line"><span class="comment"> * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data</span></span><br><span class="line"><span class="comment"> * structures are rebuilt) so that the hash table has approximately twice the</span></span><br><span class="line"><span class="comment"> * number of buckets.</span></span><br><span class="line"><span class="comment"> * HashMap 的实例有两个影响其性能的参数：初始容量和负载因子。容量是哈希表中桶的数量，初始容量只是创建哈希表时的容量。负载因子是哈希</span></span><br><span class="line"><span class="comment"> * 表在其容量自动增加之前允许达到多满的度量。当哈希表的条目数超过负载因子与当前容量的乘积时，哈希表将被重新哈希（即重建内部数据结</span></span><br><span class="line"><span class="comment"> * 构），使哈希表的桶数大约增加一倍。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As a general rule, the default load factor (.75) offers a good</span></span><br><span class="line"><span class="comment"> * tradeoff between time and space costs.  Higher values decrease the</span></span><br><span class="line"><span class="comment"> * space overhead but increase the lookup cost (reflected in most of</span></span><br><span class="line"><span class="comment"> * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in</span></span><br><span class="line"><span class="comment"> * the map and its load factor should be taken into account when</span></span><br><span class="line"><span class="comment"> * setting its initial capacity, so as to minimize the number of</span></span><br><span class="line"><span class="comment"> * rehash operations.  If the initial capacity is greater than the</span></span><br><span class="line"><span class="comment"> * maximum number of entries divided by the load factor, no rehash</span></span><br><span class="line"><span class="comment"> * operations will ever occur.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * instance, creating it with a sufficiently large capacity will allow</span></span><br><span class="line"><span class="comment"> * the mappings to be stored more efficiently than letting it perform</span></span><br><span class="line"><span class="comment"> * automatic rehashing as needed to grow the table.  Note that using</span></span><br><span class="line"><span class="comment"> * many keys with the same &#123;<span class="doctag">@code</span> hashCode()&#125; is a sure way to slow</span></span><br><span class="line"><span class="comment"> * down performance of any hash table. To ameliorate impact, when keys</span></span><br><span class="line"><span class="comment"> * are &#123;<span class="doctag">@link</span> Comparable&#125;, this class may use comparison order among</span></span><br><span class="line"><span class="comment"> * keys to help break ties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * If multiple threads access a hash map concurrently, and at least one of</span></span><br><span class="line"><span class="comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span></span><br><span class="line"><span class="comment"> * synchronized externally.  (A structural modification is any operation</span></span><br><span class="line"><span class="comment"> * that adds or deletes one or more mappings; merely changing the value</span></span><br><span class="line"><span class="comment"> * associated with a key that an instance already contains is not a</span></span><br><span class="line"><span class="comment"> * structural modification.)  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no such object exists, the map should be &quot;wrapped&quot; using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span></span><br><span class="line"><span class="comment"> * method.  This is best done at creation time, to prevent accidental</span></span><br><span class="line"><span class="comment"> * unsynchronized access to the map:&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The iterators returned by all of this class&#x27;s &quot;collection view methods&quot;</span></span><br><span class="line"><span class="comment"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span></span><br><span class="line"><span class="comment"> * the iterator is created, in any way except through the iterator&#x27;s own</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span></span><br><span class="line"><span class="comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span></span><br><span class="line"><span class="comment"> * arbitrary, non-deterministic behavior at an undetermined time in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * index = (n - 1) &amp; hash 高效取余数</span></span><br><span class="line"><span class="comment"> * ^：异或，相同取0，不同取1；</span></span><br><span class="line"><span class="comment"> * &amp;：与，1&amp;1=1，其余为0，即两位同时为“1”，结果才为“1”，否则为0；</span></span><br><span class="line"><span class="comment"> * |：或，0｜0=0，其余为1，即参加运算的两个对象只要有一个为1，其值为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、对hashCode进行16位的无符号右移</span></span><br><span class="line"><span class="comment"> * 2、对自身进行与或运算</span></span><br><span class="line"><span class="comment"> * 3、取余</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hash的再次计算能够把高位的变化影响到了低位的变化，大大减少了hash冲突</span></span><br><span class="line"><span class="comment"> * 主要是让高16位参与运算，使下标更加散列，产生更少的碰撞，增加效率。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Arthur van Hoff</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     TreeMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Hashtable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2、成员变量"><a href="#2、成员变量" class="headerlink" title="2、成员变量"></a>2、成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Implementation notes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This map usually acts as a binned (bucketed) hash table, but</span></span><br><span class="line"><span class="comment"> * when bins get too large, they are transformed into bins of</span></span><br><span class="line"><span class="comment"> * TreeNodes, each structured similarly to those in</span></span><br><span class="line"><span class="comment"> * java.util.TreeMap. Most methods try to use normal bins, but</span></span><br><span class="line"><span class="comment"> * relay to TreeNode methods when applicable (simply by checking</span></span><br><span class="line"><span class="comment"> * instanceof a node).  Bins of TreeNodes may be traversed and</span></span><br><span class="line"><span class="comment"> * used like any others, but additionally support faster lookup</span></span><br><span class="line"><span class="comment"> * when overpopulated. However, since the vast majority of bins in</span></span><br><span class="line"><span class="comment"> * normal use are not overpopulated, checking for existence of</span></span><br><span class="line"><span class="comment"> * tree bins may be delayed in the course of table methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Tree bins (i.e., bins whose elements are all TreeNodes) are</span></span><br><span class="line"><span class="comment"> * ordered primarily by hashCode, but in the case of ties, if two</span></span><br><span class="line"><span class="comment"> * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,</span></span><br><span class="line"><span class="comment"> * type then their compareTo method is used for ordering. (We</span></span><br><span class="line"><span class="comment"> * conservatively check generic types via reflection to validate</span></span><br><span class="line"><span class="comment"> * this -- see method comparableClassFor).  The added complexity</span></span><br><span class="line"><span class="comment"> * of tree bins is worthwhile in providing worst-case O(log n)</span></span><br><span class="line"><span class="comment"> * operations when keys either have distinct hashes or are</span></span><br><span class="line"><span class="comment"> * orderable, Thus, performance degrades gracefully under</span></span><br><span class="line"><span class="comment"> * accidental or malicious usages in which hashCode() methods</span></span><br><span class="line"><span class="comment"> * return values that are poorly distributed, as well as those in</span></span><br><span class="line"><span class="comment"> * which many keys share a hashCode, so long as they are also</span></span><br><span class="line"><span class="comment"> * Comparable. (If neither of these apply, we may waste about a</span></span><br><span class="line"><span class="comment"> * factor of two in time and space compared to taking no</span></span><br><span class="line"><span class="comment"> * precautions. But the only known cases stem from poor user</span></span><br><span class="line"><span class="comment"> * programming practices that are already so slow that this makes</span></span><br><span class="line"><span class="comment"> * little difference.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because TreeNodes are about twice the size of regular nodes, we</span></span><br><span class="line"><span class="comment"> * use them only when bins contain enough nodes to warrant use</span></span><br><span class="line"><span class="comment"> * (see TREEIFY_THRESHOLD). And when they become too small (due to</span></span><br><span class="line"><span class="comment"> * removal or resizing) they are converted back to plain bins.  In</span></span><br><span class="line"><span class="comment"> * usages with well-distributed user hashCodes, tree bins are</span></span><br><span class="line"><span class="comment"> * rarely used.  Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="comment"> * nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment"> * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment"> * parameter of about 0.5 on average for the default resizing</span></span><br><span class="line"><span class="comment"> * threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="comment"> * resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="comment"> * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span><br><span class="line"><span class="comment"> * factorial(k)). The first values are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0:    0.60653066</span></span><br><span class="line"><span class="comment"> * 1:    0.30326533</span></span><br><span class="line"><span class="comment"> * 2:    0.07581633</span></span><br><span class="line"><span class="comment"> * 3:    0.01263606</span></span><br><span class="line"><span class="comment"> * 4:    0.00157952</span></span><br><span class="line"><span class="comment"> * 5:    0.00015795</span></span><br><span class="line"><span class="comment"> * 6:    0.00001316</span></span><br><span class="line"><span class="comment"> * 7:    0.00000094</span></span><br><span class="line"><span class="comment"> * 8:    0.00000006</span></span><br><span class="line"><span class="comment"> * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The root of a tree bin is normally its first node.  However,</span></span><br><span class="line"><span class="comment"> * sometimes (currently only upon Iterator.remove), the root might</span></span><br><span class="line"><span class="comment"> * be elsewhere, but can be recovered following parent links</span></span><br><span class="line"><span class="comment"> * (method TreeNode.root()).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All applicable internal methods accept a hash code as an</span></span><br><span class="line"><span class="comment"> * argument (as normally supplied from a public method), allowing</span></span><br><span class="line"><span class="comment"> * them to call each other without recomputing user hashCodes.</span></span><br><span class="line"><span class="comment"> * Most internal methods also accept a &quot;tab&quot; argument, that is</span></span><br><span class="line"><span class="comment"> * normally the current table, but may be a new or old one when</span></span><br><span class="line"><span class="comment"> * resizing or converting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When bin lists are treeified, split, or untreeified, we keep</span></span><br><span class="line"><span class="comment"> * them in the same relative access/traversal order (i.e., field</span></span><br><span class="line"><span class="comment"> * Node.next) to better preserve locality, and to slightly</span></span><br><span class="line"><span class="comment"> * simplify handling of splits and traversals that invoke</span></span><br><span class="line"><span class="comment"> * iterator.remove. When using comparators on insertion, to keep a</span></span><br><span class="line"><span class="comment"> * total ordering (or as close as is required here) across</span></span><br><span class="line"><span class="comment"> * rebalancings, we compare classes and identityHashCodes as</span></span><br><span class="line"><span class="comment"> * tie-breakers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The use and transitions among plain vs tree modes is</span></span><br><span class="line"><span class="comment"> * complicated by the existence of subclass LinkedHashMap. See</span></span><br><span class="line"><span class="comment"> * below for hook methods defined to be invoked upon insertion,</span></span><br><span class="line"><span class="comment"> * removal and access that allow LinkedHashMap internals to</span></span><br><span class="line"><span class="comment"> * otherwise remain independent of these mechanics. (This also</span></span><br><span class="line"><span class="comment"> * requires that a map instance be passed to some utility methods</span></span><br><span class="line"><span class="comment"> * that may create new nodes.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The concurrent-programming-like SSA-based coding style helps</span></span><br><span class="line"><span class="comment"> * avoid aliasing errors amid all of the twisty pointer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>初始化常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> * 1073741824</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3、方法解析"><a href="#3、方法解析" class="headerlink" title="3、方法解析"></a>3、方法解析</h2><h3 id="3-1-put方法"><a href="#3-1-put方法" class="headerlink" title="3.1 put方法"></a>3.1 put方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">V <span class="title function_">put</span><span class="params">(</span></span><br><span class="line"><span class="params">  K key, </span></span><br><span class="line"><span class="params">  V value</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="comment">// 根据key计算hashcode，相对于JDK7中hash算法有所简化</span></span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-putVal方法"><a href="#3-2-putVal方法" class="headerlink" title="3.2 putVal方法"></a>3.2 putVal方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">V <span class="title function_">putVal</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="type">int</span> hash, </span></span><br><span class="line"><span class="params">			K key, </span></span><br><span class="line"><span class="params">			V value, </span></span><br><span class="line"><span class="params">			<span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> evict</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 给tab赋值，并判断数组是否为null，如果是则初始化数组，数组大小为n</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据hashcode计算对应数组的下标i，并判断该位置是否存在元素</span></span><br><span class="line">  <span class="comment">// 如果等于null，则生成一个Node对象赋值到该数组位置</span></span><br><span class="line">  <span class="comment">// 如果不为null，将该位置对应的元素取出来赋值给p</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果该下标位置存在元素，则进行一系列判断</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先判断该下标位置存在的元素的key是否和当前put进来的key相等</span></span><br><span class="line">    <span class="comment">// 如果相等，则在后续代码中更新value，并返回oldValue</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">// 如果该下标位置存在的元素的类型是TreeNode，表示该位置存的是一棵红黑树</span></span><br><span class="line">    <span class="comment">// 那么就会把新元素添加到红黑树中，并且也会判断新key是否已经存在红黑树中</span></span><br><span class="line">    <span class="comment">// 如果存在则返回该TreeNode，并在后续代码中更新value</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则该位置存的是一个链表，那就要把新元素插入到链表中</span></span><br><span class="line">      <span class="comment">// 因为要看当前链表的长度，所以需要遍历链表</span></span><br><span class="line">      <span class="comment">// 在遍历链表的过程中，一边记录链表上的元素个数，一边判断是否存在相同的key</span></span><br><span class="line">      <span class="comment">// 遍历到尾节点后，将新元素封装为Node对象，并插入到链表的尾部</span></span><br><span class="line">      <span class="comment">// 并且链表上的元素个数如果已经有8个了（不包括新元素对应的节点），则将链表改造成红黑树</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">          <span class="comment">// TREEIFY_THRESHOLD = 8</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果key相同，则更新value，返回oldValue</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 增加修改次数</span></span><br><span class="line">  ++modCount;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 新元素插入后，判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-resize方法"><a href="#3-3-resize方法" class="headerlink" title="3.3 resize方法"></a>3.3 resize方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] resize()</span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  <span class="comment">// resize()包括数组初始化和扩容</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录当前数组信息</span></span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算新数组的扩容大小、扩容阈值</span></span><br><span class="line">  <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果旧数组大小大于0，则双倍扩容</span></span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 表示要初始化数组，但用户指定了初始化容量</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="comment">// 表示要初始化数组，用默认值</span></span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用新数组的大小计算新数组的扩容阈值</span></span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 生成新数组，并赋值给table属性</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果是扩容，则把老数组上的元素转移到新数组上</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 遍历数组的每一个位置</span></span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果该位置只有一个元素，则直接转移到新数组上</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="comment">// 如果该位置上的元素是TreeNode，则对这棵红黑树进行转移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="comment">// 否则，该位置上是一个链表，则要转移链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 将当前链表拆分为两个链表，记录链表的头节点和尾节点</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 遍历链表</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="comment">// 加入低位链表</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入高位链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 将拆分后的链表转移到新数组上</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-split方法"><a href="#3-4-split方法" class="headerlink" title="3.4 split方法"></a>3.4 split方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">split</span><span class="params">(</span></span><br><span class="line"><span class="params">  HashMap&lt;K,V&gt; map, </span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> index, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> bit</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment"> * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment"> * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">  TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">  TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 由于红黑树是由链表改造而来，所以链表其实还是存在的</span></span><br><span class="line">  <span class="comment">// 对链表进行高低拆分</span></span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">    e.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">        loHead = e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        loTail.next = e;</span><br><span class="line">      loTail = e;</span><br><span class="line">      ++lc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">        hiHead = e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        hiTail.next = e;</span><br><span class="line">      hiTail = e;</span><br><span class="line">      ++hc;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拆分之后，如果存在低位链表，则看链表长度，如果小于等于6，则把节点类型改成Node类型</span></span><br><span class="line">  <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// UNTREEIFY_THRESHOLD = 6</span></span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">      tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，把头节点转移到新节点（红黑树的根节点一定是链表的头节点）</span></span><br><span class="line">      tab[index] = loHead;</span><br><span class="line">      <span class="comment">// 如果存在高位链表</span></span><br><span class="line">      <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">        loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 和上面类似</span></span><br><span class="line">  <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">      tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      tab[index + bit] = hiHead;</span><br><span class="line">      <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">        hiHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-putTreeVal方法"><a href="#3-5-putTreeVal方法" class="headerlink" title="3.5 putTreeVal方法"></a>3.5 putTreeVal方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(</span></span><br><span class="line"><span class="params">  HashMap&lt;K,V&gt; map, </span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> h, K k, </span></span><br><span class="line"><span class="params">  V v</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">  Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">    <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">      dir = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">      dir = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">        searched = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">             (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">            ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">             (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">          <span class="keyword">return</span> q;</span><br><span class="line">      &#125;</span><br><span class="line">      dir = tieBreakOrder(k, pk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">      Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">      TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">      <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">        xp.left = x;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        xp.right = x;</span><br><span class="line">      xp.next = x;</span><br><span class="line">      x.parent = x.prev = xp;</span><br><span class="line">      <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">      moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-treeifyBin方法"><a href="#3-6-treeifyBin方法" class="headerlink" title="3.6 treeifyBin方法"></a>3.6 treeifyBin方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(</span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> hash</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果长度小于MIN_TREEIFY_CAPACITY（默认为64），则会扩容</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把链表改造为双向链表，并且把节点类型改为TreeNode</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">        hd = p;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改造为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">      hd.treeify(tab);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-replacementTreeNode方法"><a href="#3-7-replacementTreeNode方法" class="headerlink" title="3.7 replacementTreeNode方法"></a>3.7 replacementTreeNode方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(</span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt; p, </span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt; next</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-8-treeify方法"><a href="#3-8-treeify方法" class="headerlink" title="3.8 treeify方法"></a>3.8 treeify方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(</span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">    x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">      x.parent = <span class="literal">null</span>;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      root = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">      Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="type">int</span> dir, ph;</span><br><span class="line">        <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">          dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">          dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">          dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">          x.parent = xp;</span><br><span class="line">          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">            xp.left = x;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            xp.right = x;</span><br><span class="line">          root = balanceInsertion(root, x);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-9-untreeify方法"><a href="#3-9-untreeify方法" class="headerlink" title="3.9 untreeify方法"></a>3.9 untreeify方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(</span></span><br><span class="line"><span class="params">  HashMap&lt;K,V&gt; map</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment"> * this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">      hd = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tl.next = p;</span><br><span class="line">    tl = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-10-红黑树方法"><a href="#3-10-红黑树方法" class="headerlink" title="3.10 红黑树方法"></a>3.10 红黑树方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br></pre></td></tr></table></figure>

<h4 id="3-9-1-rotateLeft方法"><a href="#3-9-1-rotateLeft方法" class="headerlink" title="3.9.1 rotateLeft方法"></a>3.9.1 rotateLeft方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; p</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)</span><br><span class="line">      rl.parent = p;</span><br><span class="line">    <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">      (root = r).red = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">      pp.left = r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pp.right = r;</span><br><span class="line">    r.left = p;</span><br><span class="line">    p.parent = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-2-rotateRight方法"><a href="#3-9-2-rotateRight方法" class="headerlink" title="3.9.2 rotateRight方法"></a>3.9.2 rotateRight方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; p</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">      lr.parent = p;</span><br><span class="line">    <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">      (root = l).red = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">      pp.right = l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pp.left = l;</span><br><span class="line">    l.right = p;</span><br><span class="line">    p.parent = l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-3-balanceInsertion方法"><a href="#3-9-3-balanceInsertion方法" class="headerlink" title="3.9.3 balanceInsertion方法"></a>3.9.3 balanceInsertion方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; x</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">  x.red = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">        xppr.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">false</span>;</span><br><span class="line">        xpp.red = <span class="literal">true</span>;</span><br><span class="line">        x = xpp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">          root = rotateLeft(root, x = xp);</span><br><span class="line">          xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">          xp.red = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpp.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateRight(root, xpp);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">        xppl.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">false</span>;</span><br><span class="line">        xpp.red = <span class="literal">true</span>;</span><br><span class="line">        x = xpp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">          root = rotateRight(root, x = xp);</span><br><span class="line">          xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">          xp.red = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpp.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateLeft(root, xpp);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-4-balanceDeletion方法"><a href="#3-9-4-balanceDeletion方法" class="headerlink" title="3.9.4 balanceDeletion方法"></a>3.9.4 balanceDeletion方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceDeletion</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; x</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                           TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || x == root)</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xpr = xp.right) != <span class="literal">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">        xpr.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">true</span>;</span><br><span class="line">        root = rotateLeft(root, xp);</span><br><span class="line">        xpr = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (xpr == <span class="literal">null</span>)</span><br><span class="line">        x = xp;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">        <span class="keyword">if</span> ((sr == <span class="literal">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">            (sl == <span class="literal">null</span> || !sl.red)) &#123;</span><br><span class="line">          xpr.red = <span class="literal">true</span>;</span><br><span class="line">          x = xp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (sr == <span class="literal">null</span> || !sr.red) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sl != <span class="literal">null</span>)</span><br><span class="line">              sl.red = <span class="literal">false</span>;</span><br><span class="line">            xpr.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateRight(root, xpr);</span><br><span class="line">            xpr = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">              <span class="literal">null</span> : xp.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpr.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">            <span class="keyword">if</span> ((sr = xpr.right) != <span class="literal">null</span>)</span><br><span class="line">              sr.red = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xp.red = <span class="literal">false</span>;</span><br><span class="line">            root = rotateLeft(root, xp);</span><br><span class="line">          &#125;</span><br><span class="line">          x = root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">      <span class="keyword">if</span> (xpl != <span class="literal">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">        xpl.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">true</span>;</span><br><span class="line">        root = rotateRight(root, xp);</span><br><span class="line">        xpl = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (xpl == <span class="literal">null</span>)</span><br><span class="line">        x = xp;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">        <span class="keyword">if</span> ((sl == <span class="literal">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">            (sr == <span class="literal">null</span> || !sr.red)) &#123;</span><br><span class="line">          xpl.red = <span class="literal">true</span>;</span><br><span class="line">          x = xp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (sl == <span class="literal">null</span> || !sl.red) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">              sr.red = <span class="literal">false</span>;</span><br><span class="line">            xpl.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateLeft(root, xpl);</span><br><span class="line">            xpl = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">              <span class="literal">null</span> : xp.left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xpl != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpl.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">            <span class="keyword">if</span> ((sl = xpl.left) != <span class="literal">null</span>)</span><br><span class="line">              sl.red = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xp.red = <span class="literal">false</span>;</span><br><span class="line">            root = rotateRight(root, xp);</span><br><span class="line">          &#125;</span><br><span class="line">          x = root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-5-balanceDeletion方法"><a href="#3-9-5-balanceDeletion方法" class="headerlink" title="3.9.5 balanceDeletion方法"></a>3.9.5 balanceDeletion方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">checkInvariants</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; t</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursive invariant check</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">  tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">  <span class="keyword">if</span> (tb != <span class="literal">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tn != <span class="literal">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tp != <span class="literal">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="literal">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="literal">null</span> &amp;&amp; tr.red)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h2><h3 id="4-1-允许为null"><a href="#4-1-允许为null" class="headerlink" title="4.1 允许为null"></a>4.1 允许为null</h3><p>HashTable和ConcurrentHashMap不允许键值为Null，而HashMap是允许键值为null。</p>
<p>这里简单说一下，HashTable代码是如何限制的，我们可以看下面的HashTable的put方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="comment">// Make sure the value is not null</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">  <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">      <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">      entry.value = value;</span><br><span class="line">      <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addEntry(hash, key, value, index);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当HashTable的key为null时，会直接抛出空指针异常；当HashTable的value为null时，key.hashCode()此时执行会报错。</p>
<p>再来看ConcurrentHashMap的put方法，是直接判断key或者value是否为null，如果有一个为null，则直接排除空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="comment">// 剩下的就不展示啦...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-为什么HashTable和ConcurrentHashMap要设计键值不为null呢？"><a href="#4-1-1-为什么HashTable和ConcurrentHashMap要设计键值不为null呢？" class="headerlink" title="4.1.1 为什么HashTable和ConcurrentHashMap要设计键值不为null呢？"></a>4.1.1 为什么HashTable和ConcurrentHashMap要设计键值不为null呢？</h4><p>因为它们是并发安全的类，当线程A去获取一个key&#x3D;“k”的值的时候，因为当前key不存在，所以会返回null。但同时另一个线程B插入了key&#x3D;“k”但是值为null，这个时候就会产生歧义（二义性问题），究竟是key不存在为null还是key存在但是值为null呢？而HashTable和ConcurrentHashMap又是线程安全的实现，所以它们不允许为null。</p>
<p>而HashMap就没有这个担忧了，它的值可以为null，value也可以为null。不过需要注意的是，HashMap的key为null的只能有一个，value为null的却可以有多个。</p>
<h3 id="4-2-并发不安全"><a href="#4-2-并发不安全" class="headerlink" title="4.2 并发不安全"></a>4.2 并发不安全</h3><p>HashMap是不安全的实现，HashTable和ConcurrentHashMap是安全的，HashTable锁的粒度比ConcurrentHashMap要大。</p>
<h3 id="4-3-fail-fast机制"><a href="#4-3-fail-fast机制" class="headerlink" title="4.3 fail-fast机制"></a>4.3 fail-fast机制</h3><p>fail-fast机制和fail-safe机制，两种机制都是多线程并发操作集合时的一种失败处理机制。</p>
<h4 id="4-3-1-fail-fast"><a href="#4-3-1-fail-fast" class="headerlink" title="4.3.1 fail-fast"></a>4.3.1 fail-fast</h4><p>表示快速失败，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常，从而导致遍历失败。</p>
<p>在HashMap源码中有解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &lt;p&gt;The iterators returned by all of <span class="built_in">this</span> class<span class="string">&#x27;s &quot;collection view methods&quot;</span></span><br><span class="line"><span class="string"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span></span><br><span class="line"><span class="string"> * the iterator is created, in any way except through the iterator&#x27;</span>s own</span><br><span class="line"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will <span class="keyword">throw</span> a</span><br><span class="line"> * &#123;<span class="meta">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span><br><span class="line"> * modification, the iterator fails quickly and cleanly, rather than risking</span><br><span class="line"> * arbitrary, non-deterministic behavior at an undetermined time in the</span><br><span class="line"> * future.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="line"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="line"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="line"> * <span class="keyword">throw</span> &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span><br><span class="line"> * Therefore, it would be wrong to write a program that depended on <span class="built_in">this</span></span><br><span class="line"> * exception <span class="keyword">for</span> its correctness: &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="line"> * should be used only to detect bugs.&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p>HashMap中所有“集合视图方法”返回的迭代器都是fail-fast：如果在迭代器创建后的任何时候对映射进行结构修改，除了通过迭代器自己的remove方法外，其他任何方式，迭代器将抛出ConcurrentModificationException。因此，面对并发修改，迭代器会迅速而干净地失败，而不是冒着在未来不确定的时间出现任意、不确定行为的风险。<br>迭代器的故障快速行为是无法保证的，因为一般来说，在存在不同步的并发修改的情况下，不可能做出任何硬保证。故障快速迭代器在尽力而为的基础上抛出ConcurrentModificationException。因此，编写一个依赖于此异常的正确性的程序是错误的：迭代器的快速故障行为应该只用于检测错误。</p>
<p>java.util包下的集合类都是fail-fast机制的，常见的使用fail-fast方式遍历的容器除了HashMap，还有ArrayList等。</p>
<h4 id="4-3-2-fail-safe"><a href="#4-3-2-fail-safe" class="headerlink" title="4.3.2 fail-safe"></a>4.3.2 fail-safe</h4><p>表示失败安全，也就是在这种机制下，出现集合元素的修改，不会抛出ConcurrentModificationException异常。原因是采用安全失败机制的集合容器，在遍历是不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代器是对原集合的拷贝进行遍历，所以在遍历过程中对原结合所做的修改并不能被迭代器检测到。</p>
<p>java.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发修改。常见的使用fail-safe方式遍历的容器有ConcurrentHashMap和CopyOnWriteArrayList等。</p>
<h3 id="4-4-初始容量16"><a href="#4-4-初始容量16" class="headerlink" title="4.4 初始容量16"></a>4.4 初始容量16</h3><p>HashMap底层是通过数组实现的，数组的初始容量为1 &lt;&lt; 4，为2的幂次方。那么就有两个问题，一是为什么数组的容量要为2的幂次方，二是为什么初始化容量是16而不是8或者32？基于这两个问题，作如下分析：</p>
<h4 id="4-4-1-为什么数组的容量要为2的幂次方？"><a href="#4-4-1-为什么数组的容量要为2的幂次方？" class="headerlink" title="4.4.1 为什么数组的容量要为2的幂次方？"></a>4.4.1 为什么数组的容量要为2的幂次方？</h4><p>首先，计算机是二进制的，我们所有的代码计算机执行最后都是二进制0和1。其次，二进制进行位操作效率更高，我们看源码的时候，经常发现位运算，这也是因为位运算比起一般的运算（比如取模运算，十进制运算）效率更高的原因，这也是DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4而不是DEFAULT_INITIAL_CAPACITY &#x3D; 16的原因。</p>
<h4 id="4-4-2-HashMap是如何保证数组容量一直为2的幂次方？"><a href="#4-4-2-HashMap是如何保证数组容量一直为2的幂次方？" class="headerlink" title="4.4.2 HashMap是如何保证数组容量一直为2的幂次方？"></a>4.4.2 HashMap是如何保证数组容量一直为2的幂次方？</h4><p>一是在容量初始化的时候指定容量为16，二是在扩容的时候，容量变成两倍。</p>
<h4 id="4-4-3-为什么初始化容量是16而不是8或者32呢？"><a href="#4-4-3-为什么初始化容量是16而不是8或者32呢？" class="headerlink" title="4.4.3 为什么初始化容量是16而不是8或者32呢？"></a>4.4.3 为什么初始化容量是16而不是8或者32呢？</h4><p>在源码文档里有做解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &lt;p&gt;This implementation provides constant-time performance <span class="keyword">for</span> the basic</span><br><span class="line">* operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span><br><span class="line">* disperses the elements properly among the buckets.  Iteration over</span><br><span class="line">* collection views <span class="keyword">requires</span> time proportional to the <span class="string">&quot;capacity&quot;</span> of the</span><br><span class="line">* &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its <span class="title function_">size</span> <span class="params">(the number</span></span><br><span class="line"><span class="params">* of key-value mappings)</span>.  Thus, it<span class="string">&#x27;s very important not to set the initial</span></span><br><span class="line"><span class="string">* capacity too high (or the load factor too low) if iteration performance is</span></span><br><span class="line"><span class="string">* important.</span></span><br></pre></td></tr></table></figure>

<p>此实现为基本操作（get和put）提供恒定时间性能，假设哈希函数在存储桶中正确分散元素。对集合视图进行迭代所需的时间与 HashMap 实例的“容量”（存储桶数）加上其大小（键值映射数）成正比。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或负载系数太低），这一点非常重要。</p>
<p>16是经验值的选择。</p>
<h3 id="4-5-负载因子0-75"><a href="#4-5-负载因子0-75" class="headerlink" title="4.5 负载因子0.75"></a>4.5 负载因子0.75</h3><p>负载因子表示哈希表的填满程度，跟扩容息息相关。为什么不是0.5或者1呢？</p>
<p>如果是0.5，就是说哈希表填到一半就开始扩容了，这样会导致扩容频繁，并且空间利用率比较低。 如果是1，就是说哈希表完全填满才开始扩容，这样虽然空间利用提高了，但是哈希冲突机会却大了。这里我们可以看一下源码文档的解释（总的介绍里面也有）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &lt;p&gt;As a general rule, the <span class="keyword">default</span> load <span class="title function_">factor</span> <span class="params">(<span class="number">.75</span>)</span> offers a good</span><br><span class="line">* tradeoff between time and space costs.  Higher values decrease the</span><br><span class="line">* space overhead but increase the lookup <span class="title function_">cost</span> <span class="params">(reflected in most of</span></span><br><span class="line"><span class="params">* the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span></span><br><span class="line"><span class="params">* &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;)</span>.  The expected number of entries in</span><br><span class="line">* the map and its load factor should be taken into account when</span><br><span class="line">* setting its initial capacity, so as to minimize the number of</span><br><span class="line">* rehash operations.  If the initial capacity is greater than the</span><br><span class="line">* maximum number of entries divided by the load factor, no rehash</span><br><span class="line">* operations will ever occur.</span><br></pre></td></tr></table></figure>

<p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了良好的权衡。负载因子数值越大，空间开销越低，但是会提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p>
<p>也就是说，负载因子0.75就是冲突的机会与空间利用率权衡的最后体现，也是一个程序员实验的经验值。</p>
<h3 id="4-6-扩容机制"><a href="#4-6-扩容机制" class="headerlink" title="4.6 扩容机制"></a>4.6 扩容机制</h3><p>HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。</p>
<p>在HashMap中，threshold &#x3D; loadFactor * capacity。loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置成0.75有一个好处，那就是0.75正好是3&#x2F;4，而capacity又是2的幂。所以，两个数的乘积都是整数。</p>
<p>下面是HashMap中的扩容方法(resize)中的一段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; <span class="variable constant_">MAXIMUM_CAPACITY</span> &amp;&amp;</span><br><span class="line">    oldCap &gt;= <span class="variable constant_">DEFAULT_INITIAL_CAPACITY</span>)</span><br><span class="line">    newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，扩容后的table大小变为原来的两倍，这一步执行之后，就会进行扩容后table的调整，这部分非本文重点，省略。</p>
<p>所以，通过保证初始化容量均为2的幂，并且扩容时也是扩容到之前容量的2倍，所以，保证了HashMap的容量永远都是2的幂。</p>
<h3 id="4-7-红黑树转换"><a href="#4-7-红黑树转换" class="headerlink" title="4.7 红黑树转换"></a>4.7 红黑树转换</h3><p>JDK 1.8 的 HashMap 和 ConcurrentHashMap 都有这样一个特点：最开始的 Map 是空的，因为里面没有任何元素，往里放元素时会计算 hash 值，计算之后，第 1 个 value 会首先占用一个桶（也称为槽点）位置，后续如果经过计算发现需要落到同一个桶中，那么便会使用链表的形式往后延长，这种解决hash冲突的方法称为“拉链法”。</p>
<h4 id="4-7-1-JDK1-8为什么要使用红黑树？"><a href="#4-7-1-JDK1-8为什么要使用红黑树？" class="headerlink" title="4.7.1 JDK1.8为什么要使用红黑树？"></a>4.7.1 JDK1.8为什么要使用红黑树？</h4><p>使用红黑树是为了优化hash表链表过长导致时间复杂度增加的问题。这样可以利用链表对内存的使用率以及红黑树的高效检索，是一种很有效率的数据结构。</p>
<p>但同样是树，为什么不用AVL而是使用红黑树呢？</p>
<p>AVL树是一种高度平衡的二叉树，所以查找的非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多代价。每次插入、删除都要做调整，复杂、耗时。所以，hashmap用红黑树。</p>
<h4 id="4-7-2-什么时候链表会转换为红黑树？"><a href="#4-7-2-什么时候链表会转换为红黑树？" class="headerlink" title="4.7.2 什么时候链表会转换为红黑树？"></a>4.7.2 什么时候链表会转换为红黑树？</h4><p>当链表长度大于8，且，满足容量大于或等于 MIN_TREEIFY_CAPACITY（默认为 64）时，就会把链表转换为红黑树。</p>
<p>这里要注意边界，第一个条件是链表长度大于8</p>
<h4 id="4-7-3-为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？"><a href="#4-7-3-为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？" class="headerlink" title="4.7.3 为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？"></a>4.7.3 为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TREEIFY_THRESHOLD = 8</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>

<p>我们看代码的时候，可能会困惑，这不是binCount &gt; 8 - 1 也就是链表长度大于等于7？其实，产生这样的困惑是因为代码没有看全，binCount是从0开始计数，所以在做树化判断时binCount的值等于 链表长度 - 1（注意此时的链表长度没有算新插入的节点），判断条件为 binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1也就是binCount+1（链表长度）&gt;&#x3D; TREEIFY_THRESHOLD。看到这里，有人就立马得出了链表长度大于等于8的结论，但这还是不对。因为我们没有计算新插入的节点，此时链表新插入了一个节点，所以链表树化的那一刻，它的真实长度应该是binCount +1+1（ 链表长度）&gt; TREEIFY_THRESHOLD（8）。</p>
<p>综上，所见不一定即所得，人云亦云不可取，知其然也需知其所以然！</p>
<p>第二个条件是要满足容量大于或等于64</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MIN_TREEIFY_CAPACITY = 64</span></span><br><span class="line"><span class="comment">// 先判断table的长度是否小于 MIN_TREEIFY_CAPACITY (64)</span></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">  <span class="comment">// 小于64则扩容</span></span><br><span class="line">  resize();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-4-为什么最小树形化容量是64？"><a href="#4-7-4-为什么最小树形化容量是64？" class="headerlink" title="4.7.4 为什么最小树形化容量是64？"></a>4.7.4 为什么最小树形化容量是64？</h4><p>这是因为容量低于64时，哈希碰撞的机率比较大，而这个时候出现长链表的可能性会稍微大一些，这种原因下产生的长链表，我们应该优先选择扩容而避免不必要的树化。</p>
<h4 id="4-7-5-为什么链表长度大于等于8后，还需要判断table长度是否小于MIN-TREEIFY-CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？"><a href="#4-7-5-为什么链表长度大于等于8后，还需要判断table长度是否小于MIN-TREEIFY-CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？" class="headerlink" title="4.7.5 为什么链表长度大于等于8后，还需要判断table长度是否小于MIN_TREEIFY_CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？"></a>4.7.5 为什么链表长度大于等于8后，还需要判断table长度是否小于MIN_TREEIFY_CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？</h4><p>链表长度大于8有两种情况：</p>
<ul>
<li>table长度足够，hash冲突过多</li>
<li>hash没有冲突，但是在计算table下标的时候，由于table长度太小，导致很多hash不一致的key计算的下标一致</li>
</ul>
<p>第二种情况是可以用扩容的方式来避免的，扩容后链表长度变短，读写效率自然提高。另外，扩容相对于转换为红黑树的好处在于可以保证数据结构更简单。 由此可见并不是链表长度超过8就一定会转换成红黑树，而是先尝试扩容。</p>
<h4 id="4-7-6-什么时候红黑树会转换为链表？"><a href="#4-7-6-什么时候红黑树会转换为链表？" class="headerlink" title="4.7.6 什么时候红黑树会转换为链表？"></a>4.7.6 什么时候红黑树会转换为链表？</h4><p>红黑树转换为链表有两种情况：</p>
<ul>
<li>调用map的remove方法删除元素</li>
<li>resize的时候，对红黑树进行了拆分</li>
</ul>
<p>第一种情况的话，是通过红黑树根节点及其子节点是否为空来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// removeTreeNode</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span></span><br><span class="line">    || (movable</span><br><span class="line">        &amp;&amp; (root.right == <span class="literal">null</span></span><br><span class="line">            || (rl = root.left) == <span class="literal">null</span></span><br><span class="line">            || rl.left == <span class="literal">null</span>))) &#123;</span><br><span class="line">  tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种情况，当红黑树的节点小于或等于 6 个以后，会恢复为链表形态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// UNTREEIFY_THRESHOLD = 6</span></span><br><span class="line">  <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    tab[index + bit] = hiHead;</span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">      hiHead.treeify(tab);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-7-为什么不一开始就用红黑树，而要经历一个转换的过程呢？"><a href="#4-7-7-为什么不一开始就用红黑树，而要经历一个转换的过程呢？" class="headerlink" title="4.7.7 为什么不一开始就用红黑树，而要经历一个转换的过程呢？"></a>4.7.7 为什么不一开始就用红黑树，而要经历一个转换的过程呢？</h4><p>通过查看源码可以发现，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想，最开始使用链表的时候，空间占用是比较少的，而且由于链表短，所以查询时间也没有太大的问题。可是当链表越来越长，需要用红黑树的形式来保证查询的效率。对于何时应该从链表转化为红黑树，需要确定一个阈值，这个阈值默认为 8，并且在源码中也对选择 8 这个数字做了说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">* use them only when bins contain enough nodes to warrant use</span><br><span class="line">* (see TREEIFY_THRESHOLD). And when they become too <span class="title function_">small</span> <span class="params">(due to</span></span><br><span class="line"><span class="params">* removal or resizing)</span> they are converted back to plain bins.  In</span><br><span class="line">* usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">* rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">* nodes in bins follows a Poisson distribution</span><br><span class="line">* (http:<span class="comment">//en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line">* parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span><br><span class="line">* threshold of <span class="number">0.75</span>, although with a large variance because of</span><br><span class="line">* resizing granularity. Ignoring variance, the expected</span><br><span class="line">* occurrences of list size k <span class="title function_">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * pow(<span class="number">0.5</span>, k) /</span><br><span class="line">* factorial(k)). The first values are:</span><br><span class="line">*</span><br><span class="line">* <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">* <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">* <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">* <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">* <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">* <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">* <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">* <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">* <span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">* more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure>

<p>如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p>
<p>但是，HashMap 决定某一个元素落到哪一个桶里，是和这个对象的 hashCode 有关的，JDK 并不能阻止用户实现自己的哈希算法。</p>
<h3 id="4-8-hash冲突解决方案"><a href="#4-8-hash冲突解决方案" class="headerlink" title="4.8 hash冲突解决方案"></a>4.8 hash冲突解决方案</h3><h4 id="4-8-1-开放寻址法（线性探测法）（ThreadLocal）"><a href="#4-8-1-开放寻址法（线性探测法）（ThreadLocal）" class="headerlink" title="4.8.1 开放寻址法（线性探测法）（ThreadLocal）"></a>4.8.1 开放寻址法（线性探测法）（ThreadLocal）</h4><p>从发生冲突的那个位置开始，按照一定的次序（按顺序向前）从hash表中找到一个空闲的位置，然后把发生冲突的元素存入到这个空闲的位置中。ThreadLocal就用到了线性探测法来解决hash冲突。</p>
<h4 id="4-8-2-链式寻址法（拉链法）（HashMap）"><a href="#4-8-2-链式寻址法（拉链法）（HashMap）" class="headerlink" title="4.8.2 链式寻址法（拉链法）（HashMap）"></a>4.8.2 链式寻址法（拉链法）（HashMap）</h4><p>把存在hash冲突的key，以单向链表的方式来存储，比如HashMap就是采用链式寻址法来实现的。</p>
<h4 id="4-8-3-再hash法"><a href="#4-8-3-再hash法" class="headerlink" title="4.8.3 再hash法"></a>4.8.3 再hash法</h4><p>当通过某个hash函数计算的key存在冲突时，再用另一个hash函数对这个key做hash，一直运算直至不再产生冲突。这种方式会增加计算时间，性能影响较大。</p>
<h4 id="4-8-4-建立公共溢出区"><a href="#4-8-4-建立公共溢出区" class="headerlink" title="4.8.4 建立公共溢出区"></a>4.8.4 建立公共溢出区</h4><p>把hash表分为基本表和溢出表两个部分，凡是存在冲突的元素一律放到溢出表中。</p>
<p>上面的四种是常见的解决hash冲突的方法。HashMap在JDK1.8版本中，通过链式寻址法+红黑树的方式来解决hash冲突问题。</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>阅读HashMap源码，对我们实际编程也十分受益。在我们实际编程中，也需要注意：能够使用位运算的地方尽量使用位运算；初始化的数字都需要慎重对待；数据结构是基础；优化不是一蹴而就的，但贯穿始终。</p>
<blockquote>
<p>更多HashTable和ConcurrentHashMap相关，请博客内搜索查看相关文档。</p>
</blockquote>
<blockquote>
<p>文章参考：<a href="https://juejin.cn/post/6917866631322402830">https://juejin.cn/post/6917866631322402830</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>HashMap</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>having解析</title>
    <url>/2022/01/01/having%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、having"><a href="#一、having" class="headerlink" title="一、having"></a>一、having</h1><h2 id="1、having子句语法"><a href="#1、having子句语法" class="headerlink" title="1、having子句语法"></a>1、having子句语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ... </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2, ...</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中，SELECT语句表示要查询的列，FROM子句表示要查询的表，GROUP BY子句表示要对查询结果进行分组的列，HAVING子句表示要对分组后的结果进行过滤的条件。</p>
<h2 id="2、注意事项"><a href="#2、注意事项" class="headerlink" title="2、注意事项"></a>2、注意事项</h2><p>HAVING子句有一些事项需要注意：</p>
<p>（1）分组列必须在SELECT语句中出现：使用GROUP BY子句分组时，分组列必须在SELECT语句中出现，否则会出现语法错误。</p>
<p>（2）聚合函数不能用于WHERE子句：使用聚合函数时，不能在WHERE子句中使用，因为WHERE子句在聚合函数之前执行。</p>
<p>（3）HAVING子句不能使用别名：HAVING子句不能使用SELECT语句中定义的别名，因为别名是在SELECT语句之后计算的。</p>
<p>（4）HAVING子句的条件必须是聚合函数：HAVING子句的条件必须是聚合函数，而不能是普通的列名。</p>
<p>（5）HAVING并不一定需要GROUP BY（可以参考使用场景：存在缺失的编号）。</p>
<p>（6）WHERE面向的是行，HAVING面向的是集合。</p>
<p>（7）过滤条件中有聚合函数时，则过滤条件必须声明在HAVING中；如果没有，则建议写在WHERE中，因为WHERE的执行效率要高于HAVING。</p>
<p>（8）分组操作会把分组的结果聚合成一条记录，而窗口函数（MySQL 8.0开始支持）是将结果置于每一条数据记录中。</p>
<h1 id="二、准备表数据"><a href="#二、准备表数据" class="headerlink" title="二、准备表数据"></a>二、准备表数据</h1><h2 id="1、SeqTb"><a href="#1、SeqTb" class="headerlink" title="1、SeqTb"></a>1、SeqTb</h2><table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">迪克</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">安</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">莱露</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">卡</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">玛丽</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">本</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">NULL</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">hi</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">hello</td>
</tr>
</tbody></table>
<h2 id="2、Graduates"><a href="#2、Graduates" class="headerlink" title="2、Graduates"></a>2、Graduates</h2><table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
<th align="left">income</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">桑普森</td>
<td align="left">40000</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">迈克</td>
<td align="left">30000</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">怀特</td>
<td align="left">20000</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">阿诺德</td>
<td align="left">20000</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">史密斯</td>
<td align="left">20000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">劳伦斯</td>
<td align="left">15000</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">哈德逊</td>
<td align="left">15000</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">肯特</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">贝特</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">斯科特</td>
<td align="left">10000</td>
</tr>
</tbody></table>
<h1 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h1><h2 id="1、存在缺失的编号（HAVING不一定必须有GROUP-BY）"><a href="#1、存在缺失的编号（HAVING不一定必须有GROUP-BY）" class="headerlink" title="1、存在缺失的编号（HAVING不一定必须有GROUP BY）"></a>1、存在缺失的编号（HAVING不一定必须有GROUP BY）</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果有查询结果，说明存在缺失的编号</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">as</span> gap</span><br><span class="line"><span class="keyword">from</span> SeqTb</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&lt;&gt;</span> <span class="built_in">max</span>(id)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th align="left">gap</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
</tr>
</tbody></table>
<p>explain:</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">select_type</th>
<th align="left">table</th>
<th align="left">partitions</th>
<th align="left">type</th>
<th align="left">possible_keys</th>
<th align="left">key</th>
<th align="left">key_len</th>
<th align="left">ref</th>
<th align="left">rows</th>
<th align="left">filtered</th>
<th align="left">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SIMPLE</td>
<td align="left">SeqTb</td>
<td align="left">NULL</td>
<td align="left">index</td>
<td align="left">NULL</td>
<td align="left">PRIMARY</td>
<td align="left">4</td>
<td align="left">NULL</td>
<td align="left">6</td>
<td align="left">100</td>
<td align="left">Using index</td>
</tr>
</tbody></table>
<blockquote>
<p>按照现在的 SQL 标准来说， HAVING 子句是可以单独使用的 。不过这种情况下，就不能在 SELECT 子句里引用原来的表里的列了，要么就得像示例里一样使用常量，要么就得像 SELECT COUNT(*) 这样使用聚合函数。</p>
<p>也可以认为是对空字段进行了 GROUP BY 操作，只不过省略了 GROUP BY 子句。如果使用窗口函数时不指定 PARTITION BY 子句，就是把整个表当作一个分区来处理的，思路与这里也是一样的。</p>
</blockquote>
<h2 id="2、求众数（HAVING子句进行子查询）"><a href="#2、求众数（HAVING子句进行子查询）" class="headerlink" title="2、求众数（HAVING子句进行子查询）"></a>2、求众数（HAVING子句进行子查询）</h2><p>众数：一组数据中出现次数最多的数值，有时众数在一组数中有好几个。</p>
<h3 id="2-1-使用极值表示"><a href="#2-1-使用极值表示" class="headerlink" title="2.1 使用极值表示"></a>2.1 使用极值表示</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> income, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> Graduates</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> ( </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(cnt) </span><br><span class="line">    <span class="keyword">FROM</span> ( </span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt </span><br><span class="line">        <span class="keyword">FROM</span> Graduates </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line">    ) TMP </span><br><span class="line">) ;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th align="left">income</th>
<th align="left">cnt</th>
</tr>
</thead>
<tbody><tr>
<td align="left">20000</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">10000</td>
<td align="left">3</td>
</tr>
</tbody></table>
<p>Explain：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">select_type</th>
<th align="left">table</th>
<th align="left">partitions</th>
<th align="left">type</th>
<th align="left">possible_keys</th>
<th align="left">key</th>
<th align="left">key_len</th>
<th align="left">ref</th>
<th align="left">rows</th>
<th align="left">filtered</th>
<th align="left">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">PRIMARY</td>
<td align="left">Graduates</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">10</td>
<td align="left">100</td>
<td align="left">Using temporary</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SUBQUERY</td>
<td align="left">&lt;derived3&gt;</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">10</td>
<td align="left">100</td>
<td align="left">NULL</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">DERIVED</td>
<td align="left">Graduates</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">10</td>
<td align="left">100</td>
<td align="left">Using temporary</td>
</tr>
</tbody></table>
<h3 id="2-2-使用谓词表示"><a href="#2-2-使用谓词表示" class="headerlink" title="2.2 使用谓词表示"></a>2.2 使用谓词表示</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> income, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> Graduates</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span></span><br><span class="line"><span class="keyword">ALL</span> ( </span><br><span class="line"> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"> <span class="keyword">FROM</span> Graduates</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th align="left">income</th>
<th align="left">cnt</th>
</tr>
</thead>
<tbody><tr>
<td align="left">20000</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">10000</td>
<td align="left">3</td>
</tr>
</tbody></table>
<p>Explain:</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">select_type</th>
<th align="left">table</th>
<th align="left">partitions</th>
<th align="left">type</th>
<th align="left">possible_keys</th>
<th align="left">key</th>
<th align="left">key_len</th>
<th align="left">ref</th>
<th align="left">rows</th>
<th align="left">filtered</th>
<th align="left">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">PRIMARY</td>
<td align="left">Graduates</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">10</td>
<td align="left">100</td>
<td align="left">Using temporary</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SUBQUERY</td>
<td align="left">Graduates</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">10</td>
<td align="left">100</td>
<td align="left">Using temporary</td>
</tr>
</tbody></table>
<h2 id="3、求中位数（HAVING子句进行自连接）"><a href="#3、求中位数（HAVING子句进行自连接）" class="headerlink" title="3、求中位数（HAVING子句进行自连接）"></a>3、求中位数（HAVING子句进行自连接）</h2><p>中位数：将集合里的元素按照大小分为上半部分和下半部分两个子 集，同时让这 2 个子集共同拥有集合正中间的元素。这样，共同部分 的元素的平均值就是中位数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> income)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">         <span class="keyword">SELECT</span> T1.income</span><br><span class="line">         <span class="keyword">FROM</span> Graduates T1,</span><br><span class="line">              Graduates T2</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.income</span><br><span class="line">         <span class="comment">-- S1 的条件</span></span><br><span class="line">         <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.income <span class="operator">&gt;=</span> T1.income <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="operator">&gt;=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">         <span class="comment">-- S2 的条件</span></span><br><span class="line">            <span class="keyword">AND</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.income <span class="operator">&lt;=</span> T1.income <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="operator">&gt;=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">     ) <span class="keyword">as</span> TMP</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th align="left">AVG(DISTINCT income)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">17500.0000</td>
</tr>
</tbody></table>
<p>Explain：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">select_type</th>
<th align="left">table</th>
<th align="left">partitions</th>
<th align="left">type</th>
<th align="left">possible_keys</th>
<th align="left">key</th>
<th align="left">key_len</th>
<th align="left">ref</th>
<th align="left">rows</th>
<th align="left">filtered</th>
<th align="left">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">PRIMARY</td>
<td align="left">&lt;derived2&gt;</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">100</td>
<td align="left">100</td>
<td align="left">NULL</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">DERIVED</td>
<td align="left">T1</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">10</td>
<td align="left">100</td>
<td align="left">Using temporary</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">DERIVED</td>
<td align="left">T2</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">10</td>
<td align="left">100</td>
<td align="left">Using join buffer (Block Nested Loop)</td>
</tr>
</tbody></table>
<h2 id="4、查询不包含null的集合"><a href="#4、查询不包含null的集合" class="headerlink" title="4、查询不包含null的集合"></a>4、查询不包含null的集合</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> SeqTb</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="built_in">COUNT</span>(name);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">迪克</td>
</tr>
<tr>
<td align="left">安</td>
</tr>
<tr>
<td align="left">莱露</td>
</tr>
<tr>
<td align="left">卡</td>
</tr>
<tr>
<td align="left">玛丽</td>
</tr>
<tr>
<td align="left">本</td>
</tr>
<tr>
<td align="left">hi</td>
</tr>
<tr>
<td align="left">hello</td>
</tr>
</tbody></table>
<p>Explain：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">select_type</th>
<th align="left">table</th>
<th align="left">partitions</th>
<th align="left">type</th>
<th align="left">possible_keys</th>
<th align="left">key</th>
<th align="left">key_len</th>
<th align="left">ref</th>
<th align="left">rows</th>
<th align="left">filtered</th>
<th align="left">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SIMPLE</td>
<td align="left">SeqTb</td>
<td align="left">NULL</td>
<td align="left">ALL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">9</td>
<td align="left">100</td>
<td align="left">Using temporary</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>having</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/02/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo安装部署</title>
    <url>/2023/01/01/hexo%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>一台centOs8的服务器，github账号</p>
<span id="more"></span>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><h3 id="使用yum安装git"><a href="#使用yum安装git" class="headerlink" title="使用yum安装git"></a>使用yum安装git</h3><p>执行yum报错误提示：Failed to download metadata for repo ‘base‘: Cannot download repomd.xml</p>
<p>查看系统信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 8.3.2011</span><br></pre></td></tr></table></figure>

<p>更改yum源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo</span></span><br></pre></td></tr></table></figure>

<p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install git-core</span></span><br></pre></td></tr></table></figure>

<h3 id="配置git基本信息"><a href="#配置git基本信息" class="headerlink" title="配置git基本信息"></a>配置git基本信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用ssh登录git"><a href="#使用ssh登录git" class="headerlink" title="使用ssh登录git"></a>使用ssh登录git</h3><p>生成ssh密钥文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>三个回车后，查看id_rsa.pub文件，复制内容</p>
<p>打开github的ssh配置页面，新建new SSH Key，值为刚刚复制的内容</p>
<p>检测GitHub公钥设置是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh git@github.com</span></span><br><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi Liannala! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">Connection to github.com closed.</span><br></pre></td></tr></table></figure>

<p><strong>warning</strong>：PTY allocation request failed on channel 0，提示伪终端请求失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The “PTY allocation request failed” warning is innocuous when using command-line ssh </span><br><span class="line">to login to a service that does not provide normal interactive access. </span><br><span class="line">Git-over-SSH does not need a tty and GitHub’s SSH service is configured </span><br><span class="line">to refuse to allocate one for incoming connections. </span><br><span class="line">You can tell ssh not to ask for a tty with ssh -T git@github.com.</span><br></pre></td></tr></table></figure>

<p>这个警告没有影响，它会出现是当使用命令行 SSH 登录了一个不提供正常交互式访问的服务。<br>基于 SSH 的 Git 不需要一个 tty, GitHub（GitLab 也应该一样）的 SSH 服务被配置成拒绝分配一个 tty 给入站连接。<br>你可以告诉 SSH 不要请求一个 tty，使用<code>ssh -T</code>的选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh -T git@github.com</span></span><br><span class="line">Hi Liannala! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>一切正常</p>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>通过nodesource安装nodejs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -fsSL https://rpm.nodesource.com/setup_19.x | bash -</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install -y nodejs</span></span><br></pre></td></tr></table></figure>

<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>使用npm安装hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>

<p>安装以后，可以使用以下两种方式执行 Hexo：</p>
<p>1、<code>npx hexo &lt;command&gt;</code></p>
<p>2、将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code></p>
<p>这里采用第二种方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile</span></span><br></pre></td></tr></table></figure>

<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="创建相关文件夹"><a href="#创建相关文件夹" class="headerlink" title="创建相关文件夹"></a>创建相关文件夹</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm install</span></span><br></pre></td></tr></table></figure>

<p>新建blog文件夹，初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo init blog</span></span><br></pre></td></tr></table></figure>

<h3 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo new hello_world</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: /blog/source/_posts/hello-world-1.md</span><br></pre></td></tr></table></figure>

<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo g</span></span><br></pre></td></tr></table></figure>

<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo s</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>发布完成后，需要开放服务器4000端口，这样就可以用外网访问了</p>
<h2 id="关联github"><a href="#关联github" class="headerlink" title="关联github"></a>关联github</h2><h3 id="安装git部署插件hexo-deployer-git"><a href="#安装git部署插件hexo-deployer-git" class="headerlink" title="安装git部署插件hexo-deployer-git"></a>安装git部署插件hexo-deployer-git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure>

<h3 id="打开配置文件-config-yml，修改deploy配置"><a href="#打开配置文件-config-yml，修改deploy配置" class="headerlink" title="打开配置文件_config.yml，修改deploy配置"></a>打开配置文件_config.yml，修改deploy配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="comment"># 如果配置了ssh，使用ssh的链接即可</span></span><br><span class="line">  <span class="comment"># git@github.com:hexojs/hexojs.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo clean</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo g</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo deploy</span></span><br></pre></td></tr></table></figure>

<p>完成后，打开浏览器，在地址栏输入你放置的个人网站的仓库路径，即<a href="http://xxx.github.io/">http://xxx.github.io</a></p>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>解析域名</p>
]]></content>
      <categories>
        <category>安装</category>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>安装</tag>
      </tags>
  </entry>
</search>
