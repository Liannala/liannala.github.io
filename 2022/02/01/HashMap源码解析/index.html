<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、JDK1.81、总的介绍官方注释摘录如下：">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码解析">
<meta property="og:url" content="http://example.com/2022/02/01/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Liannala&#39;s Notes">
<meta property="og:description" content="一、JDK1.81、总的介绍官方注释摘录如下：">
<meta property="og:locale">
<meta property="article:published_time" content="2022-02-01T12:11:04.000Z">
<meta property="article:modified_time" content="2022-02-01T12:11:04.000Z">
<meta property="article:author" content="Liannala">
<meta property="article:tag" content="HashMap">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/02/01/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>HashMap源码解析 | Liannala's Notes</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?732babc2877fdc07e13868c0fe35a868";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liannala's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/01/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liannala">
      <meta itemprop="description" content="Do what you love, love what you do.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liannala's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HashMap源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-01 20:11:04" itemprop="dateCreated datePublished" datetime="2022-02-01T20:11:04+08:00">2022-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、JDK1-8"><a href="#一、JDK1-8" class="headerlink" title="一、JDK1.8"></a>一、JDK1.8</h1><h2 id="1、总的介绍"><a href="#1、总的介绍" class="headerlink" title="1、总的介绍"></a>1、总的介绍</h2><p>官方注释摘录如下：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span></span><br><span class="line"><span class="comment"> * implementation provides all of the optional map operations, and permits</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</span></span><br><span class="line"><span class="comment"> * unsynchronized and permits nulls.)  This class makes no guarantees as to</span></span><br><span class="line"><span class="comment"> * the order of the map; in particular, it does not guarantee that the order</span></span><br><span class="line"><span class="comment"> * will remain constant over time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation provides constant-time performance for the basic</span></span><br><span class="line"><span class="comment"> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span></span><br><span class="line"><span class="comment"> * disperses the elements properly among the buckets.  Iteration over</span></span><br><span class="line"><span class="comment"> * collection views requires time proportional to the &quot;capacity&quot; of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</span></span><br><span class="line"><span class="comment"> * of key-value mappings).  Thus, it&#x27;s very important not to set the initial</span></span><br><span class="line"><span class="comment"> * capacity too high (or the load factor too low) if iteration performance is</span></span><br><span class="line"><span class="comment"> * important.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its</span></span><br><span class="line"><span class="comment"> * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial</span></span><br><span class="line"><span class="comment"> * capacity is simply the capacity at the time the hash table is created.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to</span></span><br><span class="line"><span class="comment"> * get before its capacity is automatically increased.  When the number of</span></span><br><span class="line"><span class="comment"> * entries in the hash table exceeds the product of the load factor and the</span></span><br><span class="line"><span class="comment"> * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data</span></span><br><span class="line"><span class="comment"> * structures are rebuilt) so that the hash table has approximately twice the</span></span><br><span class="line"><span class="comment"> * number of buckets.</span></span><br><span class="line"><span class="comment"> * HashMap 的实例有两个影响其性能的参数：初始容量和负载因子。容量是哈希表中桶的数量，初始容量只是创建哈希表时的容量。负载因子是哈希</span></span><br><span class="line"><span class="comment"> * 表在其容量自动增加之前允许达到多满的度量。当哈希表的条目数超过负载因子与当前容量的乘积时，哈希表将被重新哈希（即重建内部数据结</span></span><br><span class="line"><span class="comment"> * 构），使哈希表的桶数大约增加一倍。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As a general rule, the default load factor (.75) offers a good</span></span><br><span class="line"><span class="comment"> * tradeoff between time and space costs.  Higher values decrease the</span></span><br><span class="line"><span class="comment"> * space overhead but increase the lookup cost (reflected in most of</span></span><br><span class="line"><span class="comment"> * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in</span></span><br><span class="line"><span class="comment"> * the map and its load factor should be taken into account when</span></span><br><span class="line"><span class="comment"> * setting its initial capacity, so as to minimize the number of</span></span><br><span class="line"><span class="comment"> * rehash operations.  If the initial capacity is greater than the</span></span><br><span class="line"><span class="comment"> * maximum number of entries divided by the load factor, no rehash</span></span><br><span class="line"><span class="comment"> * operations will ever occur.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * instance, creating it with a sufficiently large capacity will allow</span></span><br><span class="line"><span class="comment"> * the mappings to be stored more efficiently than letting it perform</span></span><br><span class="line"><span class="comment"> * automatic rehashing as needed to grow the table.  Note that using</span></span><br><span class="line"><span class="comment"> * many keys with the same &#123;<span class="doctag">@code</span> hashCode()&#125; is a sure way to slow</span></span><br><span class="line"><span class="comment"> * down performance of any hash table. To ameliorate impact, when keys</span></span><br><span class="line"><span class="comment"> * are &#123;<span class="doctag">@link</span> Comparable&#125;, this class may use comparison order among</span></span><br><span class="line"><span class="comment"> * keys to help break ties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * If multiple threads access a hash map concurrently, and at least one of</span></span><br><span class="line"><span class="comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span></span><br><span class="line"><span class="comment"> * synchronized externally.  (A structural modification is any operation</span></span><br><span class="line"><span class="comment"> * that adds or deletes one or more mappings; merely changing the value</span></span><br><span class="line"><span class="comment"> * associated with a key that an instance already contains is not a</span></span><br><span class="line"><span class="comment"> * structural modification.)  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no such object exists, the map should be &quot;wrapped&quot; using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span></span><br><span class="line"><span class="comment"> * method.  This is best done at creation time, to prevent accidental</span></span><br><span class="line"><span class="comment"> * unsynchronized access to the map:&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The iterators returned by all of this class&#x27;s &quot;collection view methods&quot;</span></span><br><span class="line"><span class="comment"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span></span><br><span class="line"><span class="comment"> * the iterator is created, in any way except through the iterator&#x27;s own</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span></span><br><span class="line"><span class="comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span></span><br><span class="line"><span class="comment"> * arbitrary, non-deterministic behavior at an undetermined time in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * index = (n - 1) &amp; hash 高效取余数</span></span><br><span class="line"><span class="comment"> * ^：异或，相同取0，不同取1；</span></span><br><span class="line"><span class="comment"> * &amp;：与，1&amp;1=1，其余为0，即两位同时为“1”，结果才为“1”，否则为0；</span></span><br><span class="line"><span class="comment"> * |：或，0｜0=0，其余为1，即参加运算的两个对象只要有一个为1，其值为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、对hashCode进行16位的无符号右移</span></span><br><span class="line"><span class="comment"> * 2、对自身进行与或运算</span></span><br><span class="line"><span class="comment"> * 3、取余</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hash的再次计算能够把高位的变化影响到了低位的变化，大大减少了hash冲突</span></span><br><span class="line"><span class="comment"> * 主要是让高16位参与运算，使下标更加散列，产生更少的碰撞，增加效率。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Arthur van Hoff</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     TreeMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Hashtable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2、成员变量"><a href="#2、成员变量" class="headerlink" title="2、成员变量"></a>2、成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Implementation notes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This map usually acts as a binned (bucketed) hash table, but</span></span><br><span class="line"><span class="comment"> * when bins get too large, they are transformed into bins of</span></span><br><span class="line"><span class="comment"> * TreeNodes, each structured similarly to those in</span></span><br><span class="line"><span class="comment"> * java.util.TreeMap. Most methods try to use normal bins, but</span></span><br><span class="line"><span class="comment"> * relay to TreeNode methods when applicable (simply by checking</span></span><br><span class="line"><span class="comment"> * instanceof a node).  Bins of TreeNodes may be traversed and</span></span><br><span class="line"><span class="comment"> * used like any others, but additionally support faster lookup</span></span><br><span class="line"><span class="comment"> * when overpopulated. However, since the vast majority of bins in</span></span><br><span class="line"><span class="comment"> * normal use are not overpopulated, checking for existence of</span></span><br><span class="line"><span class="comment"> * tree bins may be delayed in the course of table methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Tree bins (i.e., bins whose elements are all TreeNodes) are</span></span><br><span class="line"><span class="comment"> * ordered primarily by hashCode, but in the case of ties, if two</span></span><br><span class="line"><span class="comment"> * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,</span></span><br><span class="line"><span class="comment"> * type then their compareTo method is used for ordering. (We</span></span><br><span class="line"><span class="comment"> * conservatively check generic types via reflection to validate</span></span><br><span class="line"><span class="comment"> * this -- see method comparableClassFor).  The added complexity</span></span><br><span class="line"><span class="comment"> * of tree bins is worthwhile in providing worst-case O(log n)</span></span><br><span class="line"><span class="comment"> * operations when keys either have distinct hashes or are</span></span><br><span class="line"><span class="comment"> * orderable, Thus, performance degrades gracefully under</span></span><br><span class="line"><span class="comment"> * accidental or malicious usages in which hashCode() methods</span></span><br><span class="line"><span class="comment"> * return values that are poorly distributed, as well as those in</span></span><br><span class="line"><span class="comment"> * which many keys share a hashCode, so long as they are also</span></span><br><span class="line"><span class="comment"> * Comparable. (If neither of these apply, we may waste about a</span></span><br><span class="line"><span class="comment"> * factor of two in time and space compared to taking no</span></span><br><span class="line"><span class="comment"> * precautions. But the only known cases stem from poor user</span></span><br><span class="line"><span class="comment"> * programming practices that are already so slow that this makes</span></span><br><span class="line"><span class="comment"> * little difference.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because TreeNodes are about twice the size of regular nodes, we</span></span><br><span class="line"><span class="comment"> * use them only when bins contain enough nodes to warrant use</span></span><br><span class="line"><span class="comment"> * (see TREEIFY_THRESHOLD). And when they become too small (due to</span></span><br><span class="line"><span class="comment"> * removal or resizing) they are converted back to plain bins.  In</span></span><br><span class="line"><span class="comment"> * usages with well-distributed user hashCodes, tree bins are</span></span><br><span class="line"><span class="comment"> * rarely used.  Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="comment"> * nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment"> * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment"> * parameter of about 0.5 on average for the default resizing</span></span><br><span class="line"><span class="comment"> * threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="comment"> * resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="comment"> * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span><br><span class="line"><span class="comment"> * factorial(k)). The first values are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0:    0.60653066</span></span><br><span class="line"><span class="comment"> * 1:    0.30326533</span></span><br><span class="line"><span class="comment"> * 2:    0.07581633</span></span><br><span class="line"><span class="comment"> * 3:    0.01263606</span></span><br><span class="line"><span class="comment"> * 4:    0.00157952</span></span><br><span class="line"><span class="comment"> * 5:    0.00015795</span></span><br><span class="line"><span class="comment"> * 6:    0.00001316</span></span><br><span class="line"><span class="comment"> * 7:    0.00000094</span></span><br><span class="line"><span class="comment"> * 8:    0.00000006</span></span><br><span class="line"><span class="comment"> * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The root of a tree bin is normally its first node.  However,</span></span><br><span class="line"><span class="comment"> * sometimes (currently only upon Iterator.remove), the root might</span></span><br><span class="line"><span class="comment"> * be elsewhere, but can be recovered following parent links</span></span><br><span class="line"><span class="comment"> * (method TreeNode.root()).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All applicable internal methods accept a hash code as an</span></span><br><span class="line"><span class="comment"> * argument (as normally supplied from a public method), allowing</span></span><br><span class="line"><span class="comment"> * them to call each other without recomputing user hashCodes.</span></span><br><span class="line"><span class="comment"> * Most internal methods also accept a &quot;tab&quot; argument, that is</span></span><br><span class="line"><span class="comment"> * normally the current table, but may be a new or old one when</span></span><br><span class="line"><span class="comment"> * resizing or converting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When bin lists are treeified, split, or untreeified, we keep</span></span><br><span class="line"><span class="comment"> * them in the same relative access/traversal order (i.e., field</span></span><br><span class="line"><span class="comment"> * Node.next) to better preserve locality, and to slightly</span></span><br><span class="line"><span class="comment"> * simplify handling of splits and traversals that invoke</span></span><br><span class="line"><span class="comment"> * iterator.remove. When using comparators on insertion, to keep a</span></span><br><span class="line"><span class="comment"> * total ordering (or as close as is required here) across</span></span><br><span class="line"><span class="comment"> * rebalancings, we compare classes and identityHashCodes as</span></span><br><span class="line"><span class="comment"> * tie-breakers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The use and transitions among plain vs tree modes is</span></span><br><span class="line"><span class="comment"> * complicated by the existence of subclass LinkedHashMap. See</span></span><br><span class="line"><span class="comment"> * below for hook methods defined to be invoked upon insertion,</span></span><br><span class="line"><span class="comment"> * removal and access that allow LinkedHashMap internals to</span></span><br><span class="line"><span class="comment"> * otherwise remain independent of these mechanics. (This also</span></span><br><span class="line"><span class="comment"> * requires that a map instance be passed to some utility methods</span></span><br><span class="line"><span class="comment"> * that may create new nodes.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The concurrent-programming-like SSA-based coding style helps</span></span><br><span class="line"><span class="comment"> * avoid aliasing errors amid all of the twisty pointer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>初始化常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> * 1073741824</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3、方法解析"><a href="#3、方法解析" class="headerlink" title="3、方法解析"></a>3、方法解析</h2><h3 id="3-1-put方法"><a href="#3-1-put方法" class="headerlink" title="3.1 put方法"></a>3.1 put方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">put</span><span class="params">(</span></span><br><span class="line"><span class="params">  K key, </span></span><br><span class="line"><span class="params">  V value</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="comment">// 根据key计算hashcode，相对于JDK7中hash算法有所简化</span></span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-putVal方法"><a href="#3-2-putVal方法" class="headerlink" title="3.2 putVal方法"></a>3.2 putVal方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">putVal</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="type">int</span> hash, </span></span><br><span class="line"><span class="params">			K key, </span></span><br><span class="line"><span class="params">			V value, </span></span><br><span class="line"><span class="params">			<span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> evict</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 给tab赋值，并判断数组是否为null，如果是则初始化数组，数组大小为n</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据hashcode计算对应数组的下标i，并判断该位置是否存在元素</span></span><br><span class="line">  <span class="comment">// 如果等于null，则生成一个Node对象赋值到该数组位置</span></span><br><span class="line">  <span class="comment">// 如果不为null，将该位置对应的元素取出来赋值给p</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果该下标位置存在元素，则进行一系列判断</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先判断该下标位置存在的元素的key是否和当前put进来的key相等</span></span><br><span class="line">    <span class="comment">// 如果相等，则在后续代码中更新value，并返回oldValue</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">// 如果该下标位置存在的元素的类型是TreeNode，表示该位置存的是一棵红黑树</span></span><br><span class="line">    <span class="comment">// 那么就会把新元素添加到红黑树中，并且也会判断新key是否已经存在红黑树中</span></span><br><span class="line">    <span class="comment">// 如果存在则返回该TreeNode，并在后续代码中更新value</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则该位置存的是一个链表，那就要把新元素插入到链表中</span></span><br><span class="line">      <span class="comment">// 因为要看当前链表的长度，所以需要遍历链表</span></span><br><span class="line">      <span class="comment">// 在遍历链表的过程中，一边记录链表上的元素个数，一边判断是否存在相同的key</span></span><br><span class="line">      <span class="comment">// 遍历到尾节点后，将新元素封装为Node对象，并插入到链表的尾部</span></span><br><span class="line">      <span class="comment">// 并且链表上的元素个数如果已经有8个了（不包括新元素对应的节点），则将链表改造成红黑树</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">          <span class="comment">// TREEIFY_THRESHOLD = 8</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果key相同，则更新value，返回oldValue</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 增加修改次数</span></span><br><span class="line">  ++modCount;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 新元素插入后，判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-resize方法"><a href="#3-3-resize方法" class="headerlink" title="3.3 resize方法"></a>3.3 resize方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] resize()</span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  <span class="comment">// resize()包括数组初始化和扩容</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录当前数组信息</span></span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算新数组的扩容大小、扩容阈值</span></span><br><span class="line">  <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果旧数组大小大于0，则双倍扩容</span></span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 表示要初始化数组，但用户指定了初始化容量</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="comment">// 表示要初始化数组，用默认值</span></span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用新数组的大小计算新数组的扩容阈值</span></span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 生成新数组，并赋值给table属性</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果是扩容，则把老数组上的元素转移到新数组上</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 遍历数组的每一个位置</span></span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果该位置只有一个元素，则直接转移到新数组上</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="comment">// 如果该位置上的元素是TreeNode，则对这棵红黑树进行转移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="comment">// 否则，该位置上是一个链表，则要转移链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 将当前链表拆分为两个链表，记录链表的头节点和尾节点</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 遍历链表</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="comment">// 加入低位链表</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入高位链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 将拆分后的链表转移到新数组上</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-split方法"><a href="#3-4-split方法" class="headerlink" title="3.4 split方法"></a>3.4 split方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">split</span><span class="params">(</span></span><br><span class="line"><span class="params">  HashMap&lt;K,V&gt; map, </span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> index, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> bit</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment"> * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment"> * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">  TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">  TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 由于红黑树是由链表改造而来，所以链表其实还是存在的</span></span><br><span class="line">  <span class="comment">// 对链表进行高低拆分</span></span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">    e.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">        loHead = e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        loTail.next = e;</span><br><span class="line">      loTail = e;</span><br><span class="line">      ++lc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">        hiHead = e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        hiTail.next = e;</span><br><span class="line">      hiTail = e;</span><br><span class="line">      ++hc;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拆分之后，如果存在低位链表，则看链表长度，如果小于等于6，则把节点类型改成Node类型</span></span><br><span class="line">  <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// UNTREEIFY_THRESHOLD = 6</span></span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">      tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，把头节点转移到新节点（红黑树的根节点一定是链表的头节点）</span></span><br><span class="line">      tab[index] = loHead;</span><br><span class="line">      <span class="comment">// 如果存在高位链表</span></span><br><span class="line">      <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">        loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 和上面类似</span></span><br><span class="line">  <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">      tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      tab[index + bit] = hiHead;</span><br><span class="line">      <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">        hiHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-putTreeVal方法"><a href="#3-5-putTreeVal方法" class="headerlink" title="3.5 putTreeVal方法"></a>3.5 putTreeVal方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(</span></span><br><span class="line"><span class="params">  HashMap&lt;K,V&gt; map, </span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> h, K k, </span></span><br><span class="line"><span class="params">  V v</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">  Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">    <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">      dir = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">      dir = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">        searched = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">             (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">            ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">             (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">          <span class="keyword">return</span> q;</span><br><span class="line">      &#125;</span><br><span class="line">      dir = tieBreakOrder(k, pk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">      Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">      TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">      <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">        xp.left = x;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        xp.right = x;</span><br><span class="line">      xp.next = x;</span><br><span class="line">      x.parent = x.prev = xp;</span><br><span class="line">      <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">      moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-treeifyBin方法"><a href="#3-6-treeifyBin方法" class="headerlink" title="3.6 treeifyBin方法"></a>3.6 treeifyBin方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(</span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> hash</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果长度小于MIN_TREEIFY_CAPACITY（默认为64），则会扩容</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把链表改造为双向链表，并且把节点类型改为TreeNode</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">        hd = p;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改造为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">      hd.treeify(tab);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-replacementTreeNode方法"><a href="#3-7-replacementTreeNode方法" class="headerlink" title="3.7 replacementTreeNode方法"></a>3.7 replacementTreeNode方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(</span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt; p, </span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt; next</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-8-treeify方法"><a href="#3-8-treeify方法" class="headerlink" title="3.8 treeify方法"></a>3.8 treeify方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(</span></span><br><span class="line"><span class="params">  Node&lt;K,V&gt;[] tab</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">    x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">      x.parent = <span class="literal">null</span>;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      root = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">      Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="type">int</span> dir, ph;</span><br><span class="line">        <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">          dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">          dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">          dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">          x.parent = xp;</span><br><span class="line">          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">            xp.left = x;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            xp.right = x;</span><br><span class="line">          root = balanceInsertion(root, x);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-9-untreeify方法"><a href="#3-9-untreeify方法" class="headerlink" title="3.9 untreeify方法"></a>3.9 untreeify方法</h3><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(</span></span><br><span class="line"><span class="params">  HashMap&lt;K,V&gt; map</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment"> * this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">      hd = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tl.next = p;</span><br><span class="line">    tl = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-10-红黑树方法"><a href="#3-10-红黑树方法" class="headerlink" title="3.10 红黑树方法"></a>3.10 红黑树方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br></pre></td></tr></table></figure>

<h4 id="3-9-1-rotateLeft方法"><a href="#3-9-1-rotateLeft方法" class="headerlink" title="3.9.1 rotateLeft方法"></a>3.9.1 rotateLeft方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; p</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)</span><br><span class="line">      rl.parent = p;</span><br><span class="line">    <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">      (root = r).red = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">      pp.left = r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pp.right = r;</span><br><span class="line">    r.left = p;</span><br><span class="line">    p.parent = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-2-rotateRight方法"><a href="#3-9-2-rotateRight方法" class="headerlink" title="3.9.2 rotateRight方法"></a>3.9.2 rotateRight方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; p</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">      lr.parent = p;</span><br><span class="line">    <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">      (root = l).red = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">      pp.right = l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pp.left = l;</span><br><span class="line">    l.right = p;</span><br><span class="line">    p.parent = l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-3-balanceInsertion方法"><a href="#3-9-3-balanceInsertion方法" class="headerlink" title="3.9.3 balanceInsertion方法"></a>3.9.3 balanceInsertion方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; x</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">  x.red = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">        xppr.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">false</span>;</span><br><span class="line">        xpp.red = <span class="literal">true</span>;</span><br><span class="line">        x = xpp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">          root = rotateLeft(root, x = xp);</span><br><span class="line">          xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">          xp.red = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpp.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateRight(root, xpp);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">        xppl.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">false</span>;</span><br><span class="line">        xpp.red = <span class="literal">true</span>;</span><br><span class="line">        x = xpp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">          root = rotateRight(root, x = xp);</span><br><span class="line">          xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">          xp.red = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpp.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateLeft(root, xpp);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-4-balanceDeletion方法"><a href="#3-9-4-balanceDeletion方法" class="headerlink" title="3.9.4 balanceDeletion方法"></a>3.9.4 balanceDeletion方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceDeletion</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; x</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                           TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || x == root)</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">      x.red = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xpr = xp.right) != <span class="literal">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">        xpr.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">true</span>;</span><br><span class="line">        root = rotateLeft(root, xp);</span><br><span class="line">        xpr = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (xpr == <span class="literal">null</span>)</span><br><span class="line">        x = xp;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">        <span class="keyword">if</span> ((sr == <span class="literal">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">            (sl == <span class="literal">null</span> || !sl.red)) &#123;</span><br><span class="line">          xpr.red = <span class="literal">true</span>;</span><br><span class="line">          x = xp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (sr == <span class="literal">null</span> || !sr.red) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sl != <span class="literal">null</span>)</span><br><span class="line">              sl.red = <span class="literal">false</span>;</span><br><span class="line">            xpr.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateRight(root, xpr);</span><br><span class="line">            xpr = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">              <span class="literal">null</span> : xp.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpr.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">            <span class="keyword">if</span> ((sr = xpr.right) != <span class="literal">null</span>)</span><br><span class="line">              sr.red = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xp.red = <span class="literal">false</span>;</span><br><span class="line">            root = rotateLeft(root, xp);</span><br><span class="line">          &#125;</span><br><span class="line">          x = root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">      <span class="keyword">if</span> (xpl != <span class="literal">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">        xpl.red = <span class="literal">false</span>;</span><br><span class="line">        xp.red = <span class="literal">true</span>;</span><br><span class="line">        root = rotateRight(root, xp);</span><br><span class="line">        xpl = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (xpl == <span class="literal">null</span>)</span><br><span class="line">        x = xp;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">        <span class="keyword">if</span> ((sl == <span class="literal">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">            (sr == <span class="literal">null</span> || !sr.red)) &#123;</span><br><span class="line">          xpl.red = <span class="literal">true</span>;</span><br><span class="line">          x = xp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (sl == <span class="literal">null</span> || !sl.red) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">              sr.red = <span class="literal">false</span>;</span><br><span class="line">            xpl.red = <span class="literal">true</span>;</span><br><span class="line">            root = rotateLeft(root, xpl);</span><br><span class="line">            xpl = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">              <span class="literal">null</span> : xp.left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xpl != <span class="literal">null</span>) &#123;</span><br><span class="line">            xpl.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">            <span class="keyword">if</span> ((sl = xpl.left) != <span class="literal">null</span>)</span><br><span class="line">              sl.red = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xp.red = <span class="literal">false</span>;</span><br><span class="line">            root = rotateRight(root, xp);</span><br><span class="line">          &#125;</span><br><span class="line">          x = root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-9-5-balanceDeletion方法"><a href="#3-9-5-balanceDeletion方法" class="headerlink" title="3.9.5 balanceDeletion方法"></a>3.9.5 balanceDeletion方法</h4><p>方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">checkInvariants</span><span class="params">(</span></span><br><span class="line"><span class="params">  TreeNode&lt;K,V&gt; t</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursive invariant check</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">  tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">  <span class="keyword">if</span> (tb != <span class="literal">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tn != <span class="literal">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tp != <span class="literal">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="literal">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="literal">null</span> &amp;&amp; tr.red)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h2><h3 id="4-1-允许为null"><a href="#4-1-允许为null" class="headerlink" title="4.1 允许为null"></a>4.1 允许为null</h3><p>HashTable和ConcurrentHashMap不允许键值为Null，而HashMap是允许键值为null。</p>
<p>这里简单说一下，HashTable代码是如何限制的，我们可以看下面的HashTable的put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="comment">// Make sure the value is not null</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">  <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">      <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">      entry.value = value;</span><br><span class="line">      <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addEntry(hash, key, value, index);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当HashTable的key为null时，会直接抛出空指针异常；当HashTable的value为null时，key.hashCode()此时执行会报错。</p>
<p>再来看ConcurrentHashMap的put方法，是直接判断key或者value是否为null，如果有一个为null，则直接排除空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="comment">// 剩下的就不展示啦...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-为什么HashTable和ConcurrentHashMap要设计键值不为null呢？"><a href="#4-1-1-为什么HashTable和ConcurrentHashMap要设计键值不为null呢？" class="headerlink" title="4.1.1 为什么HashTable和ConcurrentHashMap要设计键值不为null呢？"></a>4.1.1 为什么HashTable和ConcurrentHashMap要设计键值不为null呢？</h4><p>因为它们是并发安全的类，当线程A去获取一个key&#x3D;“k”的值的时候，因为当前key不存在，所以会返回null。但同时另一个线程B插入了key&#x3D;“k”但是值为null，这个时候就会产生歧义（二义性问题），究竟是key不存在为null还是key存在但是值为null呢？而HashTable和ConcurrentHashMap又是线程安全的实现，所以它们不允许为null。</p>
<p>而HashMap就没有这个担忧了，它的值可以为null，value也可以为null。不过需要注意的是，HashMap的key为null的只能有一个，value为null的却可以有多个。</p>
<h3 id="4-2-并发不安全"><a href="#4-2-并发不安全" class="headerlink" title="4.2 并发不安全"></a>4.2 并发不安全</h3><p>HashMap是不安全的实现，HashTable和ConcurrentHashMap是安全的，HashTable锁的粒度比ConcurrentHashMap要大。</p>
<h3 id="4-3-fail-fast机制"><a href="#4-3-fail-fast机制" class="headerlink" title="4.3 fail-fast机制"></a>4.3 fail-fast机制</h3><p>fail-fast机制和fail-safe机制，两种机制都是多线程并发操作集合时的一种失败处理机制。</p>
<h4 id="4-3-1-fail-fast"><a href="#4-3-1-fail-fast" class="headerlink" title="4.3.1 fail-fast"></a>4.3.1 fail-fast</h4><p>表示快速失败，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常，从而导致遍历失败。</p>
<p>在HashMap源码中有解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;The iterators returned by all of <span class="built_in">this</span> class<span class="string">&#x27;s &quot;collection view methods&quot;</span></span><br><span class="line"><span class="string"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span></span><br><span class="line"><span class="string"> * the iterator is created, in any way except through the iterator&#x27;</span>s own</span><br><span class="line"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will <span class="keyword">throw</span> a</span><br><span class="line"> * &#123;<span class="meta">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span><br><span class="line"> * modification, the iterator fails quickly and cleanly, rather than risking</span><br><span class="line"> * arbitrary, non-deterministic behavior at an undetermined time in the</span><br><span class="line"> * future.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="line"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="line"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="line"> * <span class="keyword">throw</span> &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span><br><span class="line"> * Therefore, it would be wrong to write a program that depended on <span class="built_in">this</span></span><br><span class="line"> * exception <span class="keyword">for</span> its correctness: &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="line"> * should be used only to detect bugs.&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p>HashMap中所有“集合视图方法”返回的迭代器都是fail-fast：如果在迭代器创建后的任何时候对映射进行结构修改，除了通过迭代器自己的remove方法外，其他任何方式，迭代器将抛出ConcurrentModificationException。因此，面对并发修改，迭代器会迅速而干净地失败，而不是冒着在未来不确定的时间出现任意、不确定行为的风险。<br>迭代器的故障快速行为是无法保证的，因为一般来说，在存在不同步的并发修改的情况下，不可能做出任何硬保证。故障快速迭代器在尽力而为的基础上抛出ConcurrentModificationException。因此，编写一个依赖于此异常的正确性的程序是错误的：迭代器的快速故障行为应该只用于检测错误。</p>
<p>java.util包下的集合类都是fail-fast机制的，常见的使用fail-fast方式遍历的容器除了HashMap，还有ArrayList等。</p>
<h4 id="4-3-2-fail-safe"><a href="#4-3-2-fail-safe" class="headerlink" title="4.3.2 fail-safe"></a>4.3.2 fail-safe</h4><p>表示失败安全，也就是在这种机制下，出现集合元素的修改，不会抛出ConcurrentModificationException异常。原因是采用安全失败机制的集合容器，在遍历是不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代器是对原集合的拷贝进行遍历，所以在遍历过程中对原结合所做的修改并不能被迭代器检测到。</p>
<p>java.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发修改。常见的使用fail-safe方式遍历的容器有ConcurrentHashMap和CopyOnWriteArrayList等。</p>
<h3 id="4-4-初始容量16"><a href="#4-4-初始容量16" class="headerlink" title="4.4 初始容量16"></a>4.4 初始容量16</h3><p>HashMap底层是通过数组实现的，数组的初始容量为1 &lt;&lt; 4，为2的幂次方。那么就有两个问题，一是为什么数组的容量要为2的幂次方，二是为什么初始化容量是16而不是8或者32？基于这两个问题，作如下分析：</p>
<h4 id="4-4-1-为什么数组的容量要为2的幂次方？"><a href="#4-4-1-为什么数组的容量要为2的幂次方？" class="headerlink" title="4.4.1 为什么数组的容量要为2的幂次方？"></a>4.4.1 为什么数组的容量要为2的幂次方？</h4><p>首先，计算机是二进制的，我们所有的代码计算机执行最后都是二进制0和1。其次，二进制进行位操作效率更高，我们看源码的时候，经常发现位运算，这也是因为位运算比起一般的运算（比如取模运算，十进制运算）效率更高的原因，这也是DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4而不是DEFAULT_INITIAL_CAPACITY &#x3D; 16的原因。</p>
<h4 id="4-4-2-HashMap是如何保证数组容量一直为2的幂次方？"><a href="#4-4-2-HashMap是如何保证数组容量一直为2的幂次方？" class="headerlink" title="4.4.2 HashMap是如何保证数组容量一直为2的幂次方？"></a>4.4.2 HashMap是如何保证数组容量一直为2的幂次方？</h4><p>一是在容量初始化的时候指定容量为16，二是在扩容的时候，容量变成两倍。</p>
<h4 id="4-4-3-为什么初始化容量是16而不是8或者32呢？"><a href="#4-4-3-为什么初始化容量是16而不是8或者32呢？" class="headerlink" title="4.4.3 为什么初始化容量是16而不是8或者32呢？"></a>4.4.3 为什么初始化容量是16而不是8或者32呢？</h4><p>在源码文档里有做解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;This implementation provides constant-time performance <span class="keyword">for</span> the basic</span><br><span class="line">* operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span><br><span class="line">* disperses the elements properly among the buckets.  Iteration over</span><br><span class="line">* collection views <span class="keyword">requires</span> time proportional to the <span class="string">&quot;capacity&quot;</span> of the</span><br><span class="line">* &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its <span class="title function_">size</span> <span class="params">(the number</span></span><br><span class="line"><span class="params">* of key-value mappings)</span>.  Thus, it<span class="string">&#x27;s very important not to set the initial</span></span><br><span class="line"><span class="string">* capacity too high (or the load factor too low) if iteration performance is</span></span><br><span class="line"><span class="string">* important.</span></span><br></pre></td></tr></table></figure>

<p>此实现为基本操作（get和put）提供恒定时间性能，假设哈希函数在存储桶中正确分散元素。对集合视图进行迭代所需的时间与 HashMap 实例的“容量”（存储桶数）加上其大小（键值映射数）成正比。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或负载系数太低），这一点非常重要。</p>
<p>16是经验值的选择。</p>
<h3 id="4-5-负载因子0-75"><a href="#4-5-负载因子0-75" class="headerlink" title="4.5 负载因子0.75"></a>4.5 负载因子0.75</h3><p>负载因子表示哈希表的填满程度，跟扩容息息相关。为什么不是0.5或者1呢？</p>
<p>如果是0.5，就是说哈希表填到一半就开始扩容了，这样会导致扩容频繁，并且空间利用率比较低。 如果是1，就是说哈希表完全填满才开始扩容，这样虽然空间利用提高了，但是哈希冲突机会却大了。这里我们可以看一下源码文档的解释（总的介绍里面也有）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;As a general rule, the <span class="keyword">default</span> load <span class="title function_">factor</span> <span class="params">(<span class="number">.75</span>)</span> offers a good</span><br><span class="line">* tradeoff between time and space costs.  Higher values decrease the</span><br><span class="line">* space overhead but increase the lookup <span class="title function_">cost</span> <span class="params">(reflected in most of</span></span><br><span class="line"><span class="params">* the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span></span><br><span class="line"><span class="params">* &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;)</span>.  The expected number of entries in</span><br><span class="line">* the map and its load factor should be taken into account when</span><br><span class="line">* setting its initial capacity, so as to minimize the number of</span><br><span class="line">* rehash operations.  If the initial capacity is greater than the</span><br><span class="line">* maximum number of entries divided by the load factor, no rehash</span><br><span class="line">* operations will ever occur.</span><br></pre></td></tr></table></figure>

<p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了良好的权衡。负载因子数值越大，空间开销越低，但是会提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p>
<p>也就是说，负载因子0.75就是冲突的机会与空间利用率权衡的最后体现，也是一个程序员实验的经验值。</p>
<h3 id="4-6-扩容机制"><a href="#4-6-扩容机制" class="headerlink" title="4.6 扩容机制"></a>4.6 扩容机制</h3><p>HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。</p>
<p>在HashMap中，threshold &#x3D; loadFactor * capacity。loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置成0.75有一个好处，那就是0.75正好是3&#x2F;4，而capacity又是2的幂。所以，两个数的乘积都是整数。</p>
<p>下面是HashMap中的扩容方法(resize)中的一段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; <span class="variable constant_">MAXIMUM_CAPACITY</span> &amp;&amp;</span><br><span class="line">    oldCap &gt;= <span class="variable constant_">DEFAULT_INITIAL_CAPACITY</span>)</span><br><span class="line">    newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，扩容后的table大小变为原来的两倍，这一步执行之后，就会进行扩容后table的调整，这部分非本文重点，省略。</p>
<p>所以，通过保证初始化容量均为2的幂，并且扩容时也是扩容到之前容量的2倍，所以，保证了HashMap的容量永远都是2的幂。</p>
<h3 id="4-7-红黑树转换"><a href="#4-7-红黑树转换" class="headerlink" title="4.7 红黑树转换"></a>4.7 红黑树转换</h3><p>JDK 1.8 的 HashMap 和 ConcurrentHashMap 都有这样一个特点：最开始的 Map 是空的，因为里面没有任何元素，往里放元素时会计算 hash 值，计算之后，第 1 个 value 会首先占用一个桶（也称为槽点）位置，后续如果经过计算发现需要落到同一个桶中，那么便会使用链表的形式往后延长，这种解决hash冲突的方法称为“拉链法”。</p>
<h4 id="4-7-1-JDK1-8为什么要使用红黑树？"><a href="#4-7-1-JDK1-8为什么要使用红黑树？" class="headerlink" title="4.7.1 JDK1.8为什么要使用红黑树？"></a>4.7.1 JDK1.8为什么要使用红黑树？</h4><p>使用红黑树是为了优化hash表链表过长导致时间复杂度增加的问题。这样可以利用链表对内存的使用率以及红黑树的高效检索，是一种很有效率的数据结构。</p>
<p>但同样是树，为什么不用AVL而是使用红黑树呢？</p>
<p>AVL树是一种高度平衡的二叉树，所以查找的非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多代价。每次插入、删除都要做调整，复杂、耗时。所以，hashmap用红黑树。</p>
<h4 id="4-7-2-什么时候链表会转换为红黑树？"><a href="#4-7-2-什么时候链表会转换为红黑树？" class="headerlink" title="4.7.2 什么时候链表会转换为红黑树？"></a>4.7.2 什么时候链表会转换为红黑树？</h4><p>当链表长度大于8，且，满足容量大于或等于 MIN_TREEIFY_CAPACITY（默认为 64）时，就会把链表转换为红黑树。</p>
<p>这里要注意边界，第一个条件是链表长度大于8</p>
<h4 id="4-7-3-为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？"><a href="#4-7-3-为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？" class="headerlink" title="4.7.3 为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？"></a>4.7.3 为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TREEIFY_THRESHOLD = 8</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>

<p>我们看代码的时候，可能会困惑，这不是binCount &gt; 8 - 1 也就是链表长度大于等于7？其实，产生这样的困惑是因为代码没有看全，binCount是从0开始计数，所以在做树化判断时binCount的值等于 链表长度 - 1（注意此时的链表长度没有算新插入的节点），判断条件为 binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1也就是binCount+1（链表长度）&gt;&#x3D; TREEIFY_THRESHOLD。看到这里，有人就立马得出了链表长度大于等于8的结论，但这还是不对。因为我们没有计算新插入的节点，此时链表新插入了一个节点，所以链表树化的那一刻，它的真实长度应该是binCount +1+1（ 链表长度）&gt; TREEIFY_THRESHOLD（8）。</p>
<p>综上，所见不一定即所得，人云亦云不可取，知其然也需知其所以然！</p>
<p>第二个条件是要满足容量大于或等于64</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIN_TREEIFY_CAPACITY = 64</span></span><br><span class="line"><span class="comment">// 先判断table的长度是否小于 MIN_TREEIFY_CAPACITY (64)</span></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">  <span class="comment">// 小于64则扩容</span></span><br><span class="line">  resize();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-4-为什么最小树形化容量是64？"><a href="#4-7-4-为什么最小树形化容量是64？" class="headerlink" title="4.7.4 为什么最小树形化容量是64？"></a>4.7.4 为什么最小树形化容量是64？</h4><p>这是因为容量低于64时，哈希碰撞的机率比较大，而这个时候出现长链表的可能性会稍微大一些，这种原因下产生的长链表，我们应该优先选择扩容而避免不必要的树化。</p>
<h4 id="4-7-5-为什么链表长度大于等于8后，还需要判断table长度是否小于MIN-TREEIFY-CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？"><a href="#4-7-5-为什么链表长度大于等于8后，还需要判断table长度是否小于MIN-TREEIFY-CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？" class="headerlink" title="4.7.5 为什么链表长度大于等于8后，还需要判断table长度是否小于MIN_TREEIFY_CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？"></a>4.7.5 为什么链表长度大于等于8后，还需要判断table长度是否小于MIN_TREEIFY_CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？</h4><p>链表长度大于8有两种情况：</p>
<ul>
<li>table长度足够，hash冲突过多</li>
<li>hash没有冲突，但是在计算table下标的时候，由于table长度太小，导致很多hash不一致的key计算的下标一致</li>
</ul>
<p>第二种情况是可以用扩容的方式来避免的，扩容后链表长度变短，读写效率自然提高。另外，扩容相对于转换为红黑树的好处在于可以保证数据结构更简单。 由此可见并不是链表长度超过8就一定会转换成红黑树，而是先尝试扩容。</p>
<h4 id="4-7-6-什么时候红黑树会转换为链表？"><a href="#4-7-6-什么时候红黑树会转换为链表？" class="headerlink" title="4.7.6 什么时候红黑树会转换为链表？"></a>4.7.6 什么时候红黑树会转换为链表？</h4><p>红黑树转换为链表有两种情况：</p>
<ul>
<li>调用map的remove方法删除元素</li>
<li>resize的时候，对红黑树进行了拆分</li>
</ul>
<p>第一种情况的话，是通过红黑树根节点及其子节点是否为空来判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeTreeNode</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span></span><br><span class="line">    || (movable</span><br><span class="line">        &amp;&amp; (root.right == <span class="literal">null</span></span><br><span class="line">            || (rl = root.left) == <span class="literal">null</span></span><br><span class="line">            || rl.left == <span class="literal">null</span>))) &#123;</span><br><span class="line">  tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种情况，当红黑树的节点小于或等于 6 个以后，会恢复为链表形态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// UNTREEIFY_THRESHOLD = 6</span></span><br><span class="line">  <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    tab[index + bit] = hiHead;</span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">      hiHead.treeify(tab);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-7-为什么不一开始就用红黑树，而要经历一个转换的过程呢？"><a href="#4-7-7-为什么不一开始就用红黑树，而要经历一个转换的过程呢？" class="headerlink" title="4.7.7 为什么不一开始就用红黑树，而要经历一个转换的过程呢？"></a>4.7.7 为什么不一开始就用红黑树，而要经历一个转换的过程呢？</h4><p>通过查看源码可以发现，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想，最开始使用链表的时候，空间占用是比较少的，而且由于链表短，所以查询时间也没有太大的问题。可是当链表越来越长，需要用红黑树的形式来保证查询的效率。对于何时应该从链表转化为红黑树，需要确定一个阈值，这个阈值默认为 8，并且在源码中也对选择 8 这个数字做了说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">* use them only when bins contain enough nodes to warrant use</span><br><span class="line">* (see TREEIFY_THRESHOLD). And when they become too <span class="title function_">small</span> <span class="params">(due to</span></span><br><span class="line"><span class="params">* removal or resizing)</span> they are converted back to plain bins.  In</span><br><span class="line">* usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">* rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">* nodes in bins follows a Poisson distribution</span><br><span class="line">* (http:<span class="comment">//en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line">* parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span><br><span class="line">* threshold of <span class="number">0.75</span>, although with a large variance because of</span><br><span class="line">* resizing granularity. Ignoring variance, the expected</span><br><span class="line">* occurrences of list size k <span class="title function_">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * pow(<span class="number">0.5</span>, k) /</span><br><span class="line">* factorial(k)). The first values are:</span><br><span class="line">*</span><br><span class="line">* <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">* <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">* <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">* <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">* <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">* <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">* <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">* <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">* <span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">* more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure>

<p>如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p>
<p>但是，HashMap 决定某一个元素落到哪一个桶里，是和这个对象的 hashCode 有关的，JDK 并不能阻止用户实现自己的哈希算法。</p>
<h3 id="4-8-hash冲突解决方案"><a href="#4-8-hash冲突解决方案" class="headerlink" title="4.8 hash冲突解决方案"></a>4.8 hash冲突解决方案</h3><h4 id="4-8-1-开放寻址法（线性探测法）（ThreadLocal）"><a href="#4-8-1-开放寻址法（线性探测法）（ThreadLocal）" class="headerlink" title="4.8.1 开放寻址法（线性探测法）（ThreadLocal）"></a>4.8.1 开放寻址法（线性探测法）（ThreadLocal）</h4><p>从发生冲突的那个位置开始，按照一定的次序（按顺序向前）从hash表中找到一个空闲的位置，然后把发生冲突的元素存入到这个空闲的位置中。ThreadLocal就用到了线性探测法来解决hash冲突。</p>
<h4 id="4-8-2-链式寻址法（拉链法）（HashMap）"><a href="#4-8-2-链式寻址法（拉链法）（HashMap）" class="headerlink" title="4.8.2 链式寻址法（拉链法）（HashMap）"></a>4.8.2 链式寻址法（拉链法）（HashMap）</h4><p>把存在hash冲突的key，以单向链表的方式来存储，比如HashMap就是采用链式寻址法来实现的。</p>
<h4 id="4-8-3-再hash法"><a href="#4-8-3-再hash法" class="headerlink" title="4.8.3 再hash法"></a>4.8.3 再hash法</h4><p>当通过某个hash函数计算的key存在冲突时，再用另一个hash函数对这个key做hash，一直运算直至不再产生冲突。这种方式会增加计算时间，性能影响较大。</p>
<h4 id="4-8-4-建立公共溢出区"><a href="#4-8-4-建立公共溢出区" class="headerlink" title="4.8.4 建立公共溢出区"></a>4.8.4 建立公共溢出区</h4><p>把hash表分为基本表和溢出表两个部分，凡是存在冲突的元素一律放到溢出表中。</p>
<p>上面的四种是常见的解决hash冲突的方法。HashMap在JDK1.8版本中，通过链式寻址法+红黑树的方式来解决hash冲突问题。</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>阅读HashMap源码，对我们实际编程也十分受益。在我们实际编程中，也需要注意：能够使用位运算的地方尽量使用位运算；初始化的数字都需要慎重对待；数据结构是基础；优化不是一蹴而就的，但贯穿始终。</p>
<blockquote>
<p>更多HashTable和ConcurrentHashMap相关，请博客内搜索查看相关文档。</p>
</blockquote>
<blockquote>
<p>文章参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6917866631322402830">https://juejin.cn/post/6917866631322402830</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/HashMap/" rel="tag"># HashMap</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/01/having%E8%A7%A3%E6%9E%90/" rel="prev" title="having解析">
      <i class="fa fa-chevron-left"></i> having解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/01/hexo%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" rel="next" title="hexo安装部署">
      hexo安装部署 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81JDK1-8"><span class="nav-number">1.</span> <span class="nav-text">一、JDK1.8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%80%BB%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">1、总的介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">2、成员变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">3、方法解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-put%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 put方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-putVal%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 putVal方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-resize%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 resize方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-split%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 split方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-putTreeVal%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 putTreeVal方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-treeifyBin%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 treeifyBin方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-replacementTreeNode%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7 replacementTreeNode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-treeify%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.8 treeify方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-untreeify%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.9.</span> <span class="nav-text">3.9 untreeify方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-%E7%BA%A2%E9%BB%91%E6%A0%91%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.10.</span> <span class="nav-text">3.10 红黑树方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-1-rotateLeft%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">3.9.1 rotateLeft方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-2-rotateRight%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.10.2.</span> <span class="nav-text">3.9.2 rotateRight方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-3-balanceInsertion%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.10.3.</span> <span class="nav-text">3.9.3 balanceInsertion方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-4-balanceDeletion%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.10.4.</span> <span class="nav-text">3.9.4 balanceDeletion方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-5-balanceDeletion%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.10.5.</span> <span class="nav-text">3.9.5 balanceDeletion方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.4.</span> <span class="nav-text">4、注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%85%81%E8%AE%B8%E4%B8%BAnull"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 允许为null</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88HashTable%E5%92%8CConcurrentHashMap%E8%A6%81%E8%AE%BE%E8%AE%A1%E9%94%AE%E5%80%BC%E4%B8%8D%E4%B8%BAnull%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1 为什么HashTable和ConcurrentHashMap要设计键值不为null呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%B9%B6%E5%8F%91%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 并发不安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-fail-fast%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 fail-fast机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-fail-fast"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">4.3.1 fail-fast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-fail-safe"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">4.3.2 fail-safe</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F16"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 初始容量16</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%B9%E9%87%8F%E8%A6%81%E4%B8%BA2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9%EF%BC%9F"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.4.1 为什么数组的容量要为2的幂次方？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F%E4%B8%80%E7%9B%B4%E4%B8%BA2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9%EF%BC%9F"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.4.2 HashMap是如何保证数组容量一直为2的幂次方？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E6%98%AF16%E8%80%8C%E4%B8%8D%E6%98%AF8%E6%88%96%E8%80%8532%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">4.4.3 为什么初始化容量是16而不是8或者32呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%900-75"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 负载因子0.75</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.6.</span> <span class="nav-text">4.6 扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.7.</span> <span class="nav-text">4.7 红黑树转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1-JDK1-8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">4.7.1 JDK1.8为什么要使用红黑树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%93%BE%E8%A1%A8%E4%BC%9A%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">4.7.2 什么时候链表会转换为红黑树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E7%EF%BC%9F"><span class="nav-number">1.4.7.3.</span> <span class="nav-text">4.7.3 为什么是链表长度大于8？为什么不是大于等于8？为什么不是大于等于7？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%8C%96%E5%AE%B9%E9%87%8F%E6%98%AF64%EF%BC%9F"><span class="nav-number">1.4.7.4.</span> <span class="nav-text">4.7.4 为什么最小树形化容量是64？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E8%E5%90%8E%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E5%88%A4%E6%96%ADtable%E9%95%BF%E5%BA%A6%E6%98%AF%E5%90%A6%E5%B0%8F%E4%BA%8EMIN-TREEIFY-CAPACITY%E5%91%A2%EF%BC%9F%E5%B0%8F%E4%BA%8E%E7%9A%84%E8%AF%9D%E4%BC%9A%E7%9B%B4%E6%8E%A5%E6%89%A9%E5%AE%B9%EF%BC%8C%E5%A4%A7%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8E%E6%89%8D%E4%BC%9A%E8%BD%AC%E6%8D%A2%E7%BA%A2%E9%BB%91%E6%A0%91%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.7.5.</span> <span class="nav-text">4.7.5 为什么链表长度大于等于8后，还需要判断table长度是否小于MIN_TREEIFY_CAPACITY呢？小于的话会直接扩容，大于或等于才会转换红黑树呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BC%9A%E8%BD%AC%E6%8D%A2%E4%B8%BA%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.4.7.6.</span> <span class="nav-text">4.7.6 什么时候红黑树会转换为链表？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%B8%80%E5%BC%80%E5%A7%8B%E5%B0%B1%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E8%80%8C%E8%A6%81%E7%BB%8F%E5%8E%86%E4%B8%80%E4%B8%AA%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.7.7.</span> <span class="nav-text">4.7.7 为什么不一开始就用红黑树，而要经历一个转换的过程呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-hash%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.8.</span> <span class="nav-text">4.8 hash冲突解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-1-%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%EF%BC%88%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%EF%BC%89%EF%BC%88ThreadLocal%EF%BC%89"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">4.8.1 开放寻址法（线性探测法）（ThreadLocal）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-2-%E9%93%BE%E5%BC%8F%E5%AF%BB%E5%9D%80%E6%B3%95%EF%BC%88%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%89%EF%BC%88HashMap%EF%BC%89"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">4.8.2 链式寻址法（拉链法）（HashMap）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-3-%E5%86%8Dhash%E6%B3%95"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">4.8.3 再hash法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="nav-number">1.4.8.4.</span> <span class="nav-text">4.8.4 建立公共溢出区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">5、总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liannala</p>
  <div class="site-description" itemprop="description">Do what you love, love what you do.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:zhulianna199411@gmail.com" title="E-Mail → mailto:zhulianna199411@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liannala</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
